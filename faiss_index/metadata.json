{
    "chunks": [
        {
            "chunkId": "97a0f418-988a-4f19-a480-4e6e2bcd39bc",
            "filePath": "composeApp/src/androidMain/kotlin/ru/alekseev/myapplication/permissions/PermissionsWrapper.android.kt",
            "content": "package ru.alekseev.myapplication.permissions import androidx.compose.runtime.Composable import androidx.compose.runtime.remember import dev.icerock.moko.permissions.DeniedAlwaysException import dev.icerock.moko.permissions.DeniedException import dev.icerock.moko.permissions.Permission import dev.icerock.moko.permissions.PermissionsController import dev.icerock.moko.permissions.compose.BindEffect import dev.icerock.moko.permissions.compose.PermissionsControllerFactory import dev.icerock.moko.permissions.compose.rememberPermissionsControllerFactory import dev.icerock.moko.permissions.notifications.REMOTE_NOTIFICATION class MokoPermissionsWrapper( private val controller: PermissionsController ) : PermissionsWrapper { @Composable override fun BindEffect() { BindEffect(controller) } override suspend fun requestNotificationPermission() { try { controller.providePermission(Permission.REMOTE_NOTIFICATION) } catch (e: DeniedException) { throw PermissionDeniedException(\"Permission denied: ${e.message}\") } catch (e: DeniedAlwaysException) { throw PermissionDeniedException(\"Permission denied always: ${e.message}\") } } } @Composable actual fun rememberPermissionsWrapper(): PermissionsWrapper { val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory() val controller: PermissionsController = remember(factory) { factory.createPermissionsController() } return remember(controller) { MokoPermissionsWrapper(controller) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 94,
            "fileType": "kt"
        },
        {
            "chunkId": "6794f944-61bc-4fde-b8df-2ec006b45e23",
            "filePath": "composeApp/src/androidMain/kotlin/ru/alekseev/myapplication/MainActivity.kt",
            "content": "package ru.alekseev.myapplication import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import com.arkivanov.decompose.defaultComponentContext import org.koin.android.ext.android.inject import ru.alekseev.myapplication.root.DefaultRootComponent import ru.alekseev.myapplication.root.RootContent class MainActivity : ComponentActivity() { private val activityProvider: ActivityProvider by inject() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) activityProvider.set(this) val root = DefaultRootComponent(componentContext = defaultComponentContext()) setContent { RootContent(component = root) } } override fun onDestroy() { activityProvider.clear(this) super.onDestroy() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 55,
            "fileType": "kt"
        },
        {
            "chunkId": "addc5607-665a-4a30-98f8-77f2a1003158",
            "filePath": "composeApp/src/androidMain/kotlin/ru/alekseev/myapplication/MyApplication.kt",
            "content": "package ru.alekseev.myapplication import android.app.Application import com.example.myapplication.feature_main.di.featureMainModule import org.koin.android.ext.koin.androidContext import org.koin.android.ext.koin.androidLogger import org.koin.core.context.startKoin import ru.alekseev.myapplication.di.platformModule class MyApplication : Application() { override fun onCreate() { super.onCreate() startKoin { androidLogger() androidContext(this@MyApplication) modules( platformModule, featureMainModule ) } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 35,
            "fileType": "kt"
        },
        {
            "chunkId": "cbe5b722-7fa1-4ae3-acd2-ff5e22b255a6",
            "filePath": "composeApp/src/androidMain/res/drawable/ic_launcher_background.xml",
            "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"108dp\" android:height=\"108dp\" android:viewportWidth=\"108\" android:viewportHeight=\"108\"> <path android:fillColor=\"#3DDC84\" android:pathData=\"M0,0h108v108h-108z\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M9,0L9,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M19,0L19,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M29,0L29,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M39,0L39,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M49,0L49,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M59,0L59,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M69,0L69,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M79,0L79,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M89,0L89,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M99,0L99,108\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,9L108,9\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,19L108,19\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,29L108,29\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,39L108,39\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,49L108,49\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,59L108,59\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,69L108,69\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,79L108,79\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,89L108,89\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M0,99L108,99\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M19,29L89,29\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M19,39L89,39\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M19,49L89,49\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M19,59L89,59\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M19,69L89,69\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M19,79L89,79\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M29,19L29,89\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M39,19L39,89\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M49,19L49,89\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M59,19L59,89\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M69,19L69,89\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> <path android:fillColor=\"#00000000\" android:pathData=\"M79,19L79,89\" android:strokeWidth=\"0.8\" android:strokeColor=\"#33FFFFFF\" /> </vector>",
            "startTokenIndex": 0,
            "endTokenIndex": 206,
            "fileType": "xml"
        },
        {
            "chunkId": "d059bf6d-84e6-45d0-80a1-08d2fb08ba7a",
            "filePath": "composeApp/src/androidMain/res/drawable-v24/ic_launcher_foreground.xml",
            "content": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:aapt=\"http://schemas.android.com/aapt\" android:width=\"108dp\" android:height=\"108dp\" android:viewportWidth=\"108\" android:viewportHeight=\"108\"> <path android:pathData=\"M31,63.928c0,0 6.4,-11 12.1,-13.1c7.2,-2.6 26,-1.4 26,-1.4l38.1,38.1L107,108.928l-32,-1L31,63.928z\"> <aapt:attr name=\"android:fillColor\"> <gradient android:endX=\"85.84757\" android:endY=\"92.4963\" android:startX=\"42.9492\" android:startY=\"49.59793\" android:type=\"linear\"> <item android:color=\"#44000000\" android:offset=\"0.0\" /> <item android:color=\"#00000000\" android:offset=\"1.0\" /> </gradient> </aapt:attr> </path> <path android:fillColor=\"#FFFFFF\" android:fillType=\"nonZero\" android:pathData=\"M65.3,45.828l3.8,-6.6c0.2,-0.4 0.1,-0.9 -0.3,-1.1c-0.4,-0.2 -0.9,-0.1 -1.1,0.3l-3.9,6.7c-6.3,-2.8 -13.4,-2.8 -19.7,0l-3.9,-6.7c-0.2,-0.4 -0.7,-0.5 -1.1,-0.3C38.8,38.328 38.7,38.828 38.9,39.228l3.8,6.6C36.2,49.428 31.7,56.028 31,63.928h46C76.3,56.028 71.8,49.428 65.3,45.828zM43.4,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2c-0.3,-0.7 -0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C45.3,56.528 44.5,57.328 43.4,57.328L43.4,57.328zM64.6,57.328c-0.8,0 -1.5,-0.5 -1.8,-1.2s-0.1,-1.5 0.4,-2.1c0.5,-0.5 1.4,-0.7 2.1,-0.4c0.7,0.3 1.2,1 1.2,1.8C66.5,56.528 65.6,57.328 64.6,57.328L64.6,57.328z\" android:strokeWidth=\"1\" android:strokeColor=\"#00000000\" /> </vector>",
            "startTokenIndex": 0,
            "endTokenIndex": 73,
            "fileType": "xml"
        },
        {
            "chunkId": "a3ddae8f-136f-458d-89fe-03d35e69218a",
            "filePath": "composeApp/src/androidMain/res/mipmap-anydpi-v26/ic_launcher.xml",
            "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <adaptive-icon xmlns:android=\"http://schemas.android.com/apk/res/android\"> <background android:drawable=\"@drawable/ic_launcher_background\" /> <foreground android:drawable=\"@drawable/ic_launcher_foreground\" /> </adaptive-icon>",
            "startTokenIndex": 0,
            "endTokenIndex": 12,
            "fileType": "xml"
        },
        {
            "chunkId": "c16397c0-dc54-47ea-9767-e9dee94fc4e7",
            "filePath": "composeApp/src/androidMain/res/mipmap-anydpi-v26/ic_launcher_round.xml",
            "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <adaptive-icon xmlns:android=\"http://schemas.android.com/apk/res/android\"> <background android:drawable=\"@drawable/ic_launcher_background\" /> <foreground android:drawable=\"@drawable/ic_launcher_foreground\" /> </adaptive-icon>",
            "startTokenIndex": 0,
            "endTokenIndex": 12,
            "fileType": "xml"
        },
        {
            "chunkId": "52ce9dc2-990e-4a39-8254-8c210d85bda5",
            "filePath": "composeApp/src/androidMain/res/values/strings.xml",
            "content": "<resources> <string name=\"app_name\">MyApplication</string> </resources>",
            "startTokenIndex": 0,
            "endTokenIndex": 4,
            "fileType": "xml"
        },
        {
            "chunkId": "39070a5c-31b7-4559-868c-100a44050e8b",
            "filePath": "composeApp/src/androidMain/res/xml/network_security_config.xml",
            "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <network-security-config> <!-- Allow cleartext (HTTP/WS) for local development --> <domain-config cleartextTrafficPermitted=\"true\"> <!-- Localhost --> <domain includeSubdomains=\"true\">localhost</domain> <!-- Android emulator host access --> <domain includeSubdomains=\"true\">10.0.2.2</domain> </domain-config> <!-- Allow cleartext for local network (192.168.x.x) --> <domain-config cleartextTrafficPermitted=\"true\"> <domain includeSubdomains=\"true\">192.168.0.14</domain> <domain includeSubdomains=\"true\">192.168.0.18</domain> </domain-config> </network-security-config>",
            "startTokenIndex": 0,
            "endTokenIndex": 44,
            "fileType": "xml"
        },
        {
            "chunkId": "0e48eca8-ef56-441d-ab70-7798e4358915",
            "filePath": "composeApp/src/androidMain/AndroidManifest.xml",
            "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"> <uses-permission android:name=\"android.permission.INTERNET\" /> <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" /> <application android:name=\".MyApplication\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@android:style/Theme.Material.Light.NoActionBar\" android:networkSecurityConfig=\"@xml/network_security_config\"> <activity android:exported=\"true\" android:name=\".MainActivity\"> <intent-filter> <action android:name=\"android.intent.action.MAIN\" /> <category android:name=\"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest>",
            "startTokenIndex": 0,
            "endTokenIndex": 34,
            "fileType": "xml"
        },
        {
            "chunkId": "9839840f-b12d-4233-83db-b5fa41600634",
            "filePath": "composeApp/src/commonMain/composeResources/drawable/compose-multiplatform.xml",
            "content": "<vector xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:aapt=\"http://schemas.android.com/aapt\" android:width=\"450dp\" android:height=\"450dp\" android:viewportWidth=\"64\" android:viewportHeight=\"64\"> <path android:pathData=\"M56.25,18V46L32,60 7.75,46V18L32,4Z\" android:fillColor=\"#6075f2\"/> <path android:pathData=\"m41.5,26.5v11L32,43V60L56.25,46V18Z\" android:fillColor=\"#6b57ff\"/> <path android:pathData=\"m32,43 l-9.5,-5.5v-11L7.75,18V46L32,60Z\"> <aapt:attr name=\"android:fillColor\"> <gradient android:centerX=\"23.131\" android:centerY=\"18.441\" android:gradientRadius=\"42.132\" android:type=\"radial\"> <item android:offset=\"0\" android:color=\"#FF5383EC\"/> <item android:offset=\"0.867\" android:color=\"#FF7F52FF\"/> </gradient> </aapt:attr> </path> <path android:pathData=\"M22.5,26.5 L32,21 41.5,26.5 56.25,18 32,4 7.75,18Z\"> <aapt:attr name=\"android:fillColor\"> <gradient android:startX=\"44.172\" android:startY=\"4.377\" android:endX=\"17.973\" android:endY=\"34.035\" android:type=\"linear\"> <item android:offset=\"0\" android:color=\"#FF33C3FF\"/> <item android:offset=\"0.878\" android:color=\"#FF5383EC\"/> </gradient> </aapt:attr> </path> <path android:pathData=\"m32,21 l9.526,5.5v11L32,43 22.474,37.5v-11z\" android:fillColor=\"#000000\"/> </vector>",
            "startTokenIndex": 0,
            "endTokenIndex": 63,
            "fileType": "xml"
        },
        {
            "chunkId": "fc479263-09e7-42dc-a581-2c1c6d9aacd7",
            "filePath": "composeApp/src/commonMain/kotlin/androidx/compose/desktop/ui/tooling/preview/Preview.kt",
            "content": "package androidx.compose.desktop.ui.tooling.preview @OptIn(ExperimentalMultiplatform::class) @OptionalExpectation expect annotation class Preview()",
            "startTokenIndex": 0,
            "endTokenIndex": 8,
            "fileType": "kt"
        },
        {
            "chunkId": "37252e72-2fec-499e-94c5-509f0ecaf768",
            "filePath": "composeApp/src/commonMain/kotlin/ru/alekseev/myapplication/main/messageinfo/MessageInfoContent.kt",
            "content": "package ru.alekseev.myapplication.main.messageinfo import androidx.compose.foundation.layout.Arrangement import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.Row import androidx.compose.foundation.layout.fillMaxWidth import androidx.compose.material3.AlertDialog import androidx.compose.material3.Text import androidx.compose.material3.TextButton import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier import androidx.compose.ui.graphics.Color import androidx.compose.ui.text.font.FontWeight import androidx.compose.ui.unit.dp import androidx.compose.ui.unit.sp import com.example.myapplication.feature_main.presentation.messageinfo.MessageInfoComponent import ru.alekseev.myapplication.utils.formatUsd @Composable fun MessageInfoContent( component: MessageInfoComponent, modifier: Modifier = Modifier ) { val messageInfo = component.messageInfo AlertDialog( onDismissRequest = component::onDismiss, title = { Text( text = \"Message Information\", fontWeight = FontWeight.Bold, fontSize = 20.sp, color = Color.White ) }, text = { Column( verticalArrangement = Arrangement.spacedBy(12.dp) ) { InfoRow(label = \"Input Tokens\", value = messageInfo.inputTokens.toString()) InfoRow(label = \"Output Tokens\", value = messageInfo.outputTokens.toString()) InfoRow( label = \"Total Tokens\", value = (messageInfo.inputTokens + messageInfo.outputTokens).toString() ) InfoRow(label = \"Response Time\", value = \"${messageInfo.responseTimeMs}ms\") InfoRow(label = \"Model\", value = messageInfo.model) InfoRow(label = \"Cost\", value = formatUsd(messageInfo.cost)) } }, confirmButton = { TextButton(onClick = component::onDismiss) { Text(\"Close\", color = Color(0xFF6C63FF)) } }, containerColor = Color(0xFF1A1A2E), textContentColor = Color.White, modifier = modifier ) } @Composable private fun InfoRow(label: String, value: String) { Row( modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceBetween ) { Text( text = label, color = Color.Gray, fontSize = 14.sp ) Text( text = value, color = Color.White, fontSize = 14.sp, fontWeight = FontWeight.Medium ) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 193,
            "fileType": "kt"
        },
        {
            "chunkId": "384d3738-72f9-4e68-b510-5f68afb52091",
            "filePath": "composeApp/src/commonMain/kotlin/ru/alekseev/myapplication/permissions/PermissionsWrapper.kt",
            "content": "package ru.alekseev.myapplication.permissions import androidx.compose.runtime.Composable /** * Wrapper for permissions functionality that works across all platforms */ interface PermissionsWrapper { /** * Binds the permissions controller lifecycle to the current composition */ @Composable fun BindEffect() /** * Requests notification permission * @throws PermissionDeniedException if permission is denied */ suspend fun requestNotificationPermission() } /** * Exception thrown when permission is denied */ class PermissionDeniedException(message: String? = null) : Exception(message) /** * Factory function to create platform-specific permissions wrapper */ @Composable expect fun rememberPermissionsWrapper(): PermissionsWrapper",
            "startTokenIndex": 0,
            "endTokenIndex": 82,
            "fileType": "kt"
        },
        {
            "chunkId": "de977e63-4c1d-4ee6-9a50-8bccb127db32",
            "filePath": "composeApp/src/commonMain/kotlin/ru/alekseev/myapplication/root/DefaultRootComponent.kt",
            "content": "package ru.alekseev.myapplication.root import com.arkivanov.decompose.ComponentContext import com.arkivanov.decompose.router.stack.ChildStack import com.arkivanov.decompose.router.stack.StackNavigation import com.arkivanov.decompose.router.stack.childStack import com.arkivanov.decompose.router.stack.pop import com.arkivanov.decompose.router.stack.popTo import com.arkivanov.decompose.value.Value import com.example.myapplication.feature_main.presentation.DefaultMainComponent import com.example.myapplication.feature_main.presentation.MainComponent import com.example.myapplication.feature_welcome.presentation.DefaultWelcomeComponent import com.example.myapplication.feature_welcome.presentation.WelcomeComponent import kotlinx.serialization.Serializable class DefaultRootComponent( componentContext: ComponentContext, ) : RootComponent, ComponentContext by componentContext { private val navigation = StackNavigation<Config>() override val stack: Value<ChildStack<*, RootComponent.Child>> = childStack( source = navigation, serializer = Config.serializer(), initialConfiguration = Config.Main, handleBackButton = true, childFactory = ::child, ) private fun child(config: Config, childComponentContext: ComponentContext): RootComponent.Child = when (config) { is Config.Main -> RootComponent.Child.Main(mainComponent(childComponentContext)) is Config.Welcome -> RootComponent.Child.Welcome(welcomeComponent(childComponentContext)) } private fun mainComponent(componentContext: ComponentContext): MainComponent = DefaultMainComponent( componentContext = componentContext, ) private fun welcomeComponent(componentContext: ComponentContext): WelcomeComponent = DefaultWelcomeComponent( componentContext = componentContext, onFinished = navigation::pop, ) override fun onBackClicked(toIndex: Int) { navigation.popTo(index = toIndex) } @Serializable private sealed interface Config { @Serializable data object Main : Config @Serializable data object Welcome : Config } }",
            "startTokenIndex": 0,
            "endTokenIndex": 139,
            "fileType": "kt"
        },
        {
            "chunkId": "41de631b-29af-44ce-a44a-eeb5ccdcc003",
            "filePath": "composeApp/src/commonMain/kotlin/ru/alekseev/myapplication/root/RootComponent.kt",
            "content": "package ru.alekseev.myapplication.root import com.arkivanov.decompose.router.stack.ChildStack import com.arkivanov.decompose.value.Value import com.example.myapplication.feature_main.presentation.MainComponent import com.example.myapplication.feature_welcome.presentation.WelcomeComponent interface RootComponent { val stack: Value<ChildStack<*, Child>> fun onBackClicked(toIndex: Int) sealed class Child { class Main(val component: MainComponent) : Child() class Welcome(val component: WelcomeComponent) : Child() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 38,
            "fileType": "kt"
        },
        {
            "chunkId": "fecb2852-db87-45e5-9926-6aedeeff2fd1",
            "filePath": "composeApp/src/commonMain/kotlin/ru/alekseev/myapplication/root/RootContent.kt",
            "content": "package ru.alekseev.myapplication.root import androidx.compose.foundation.layout.WindowInsets import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.foundation.layout.systemBars import androidx.compose.foundation.layout.windowInsetsPadding import androidx.compose.material3.MaterialTheme import androidx.compose.material3.Surface import androidx.compose.runtime.Composable import androidx.compose.ui.Modifier import com.arkivanov.decompose.extensions.compose.stack.Children import com.arkivanov.decompose.extensions.compose.stack.animation.fade import com.arkivanov.decompose.extensions.compose.stack.animation.plus import com.arkivanov.decompose.extensions.compose.stack.animation.scale import com.arkivanov.decompose.extensions.compose.stack.animation.stackAnimation import ru.alekseev.myapplication.main.MainContent import ru.alekseev.myapplication.welcome.WelcomeContent @Composable fun RootContent( component: RootComponent, modifier: Modifier = Modifier, ) { MaterialTheme { Surface(modifier = modifier.fillMaxSize().windowInsetsPadding(WindowInsets.systemBars)) { Children( stack = component.stack, modifier = Modifier.fillMaxSize(), animation = stackAnimation(fade() + scale()) ) { when (val instance = it.instance) { is RootComponent.Child.Main -> MainContent(component = instance.component) is RootComponent.Child.Welcome -> WelcomeContent(component = instance.component) } } } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 86,
            "fileType": "kt"
        },
        {
            "chunkId": "2328134c-7501-4c6e-9f78-3dc6e356365d",
            "filePath": "composeApp/src/commonMain/kotlin/ru/alekseev/myapplication/utils/Utils.kt",
            "content": "package ru.alekseev.myapplication.utils fun formatUsd(value: Double): String { return \"$\" + (kotlin.math.round(value * 1_000_000) / 1_000_000).toString() }",
            "startTokenIndex": 0,
            "endTokenIndex": 16,
            "fileType": "kt"
        },
        {
            "chunkId": "f19a72cd-3db2-4a24-a46c-ebb9a9bd4079",
            "filePath": "composeApp/src/commonMain/kotlin/ru/alekseev/myapplication/welcome/WelcomeContent.kt",
            "content": "package ru.alekseev.myapplication.welcome import androidx.compose.desktop.ui.tooling.preview.Preview import androidx.compose.foundation.layout.Arrangement import androidx.compose.foundation.layout.Column import androidx.compose.foundation.layout.fillMaxSize import androidx.compose.material.icons.Icons import androidx.compose.material.icons.automirrored.filled.ArrowBack import androidx.compose.material3.Button import androidx.compose.material3.ExperimentalMaterial3Api import androidx.compose.material3.Icon import androidx.compose.material3.IconButton import androidx.compose.material3.Scaffold import androidx.compose.material3.Text import androidx.compose.material3.TopAppBar import androidx.compose.runtime.Composable import androidx.compose.runtime.getValue import androidx.compose.ui.Alignment import androidx.compose.ui.Modifier import com.arkivanov.decompose.extensions.compose.subscribeAsState import com.example.myapplication.feature_welcome.presentation.PreviewWelcomeComponent import com.example.myapplication.feature_welcome.presentation.WelcomeComponent @OptIn(ExperimentalMaterial3Api::class) @Composable internal fun WelcomeContent( component: WelcomeComponent, modifier: Modifier = Modifier, ) { val model by component.model.subscribeAsState() Scaffold( modifier = modifier, topBar = { TopAppBar( title = { Text(text = \"Welcome Screen\") }, navigationIcon = { IconButton(onClick = component::onBackClicked) { Icon( imageVector = Icons.AutoMirrored.Default.ArrowBack, contentDescription = \"Back button\", ) } }, ) }, ) { Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center, ) { Button( onClick = { component.onUpdateGreetingText() }, ) { Text(model.greetingText) } } } } @Preview @Composable fun WelcomePreview() { WelcomeContent(PreviewWelcomeComponent) }",
            "startTokenIndex": 0,
            "endTokenIndex": 129,
            "fileType": "kt"
        },
        {
            "chunkId": "250bd27a-8652-407a-846c-fb8c405df4ea",
            "filePath": "composeApp/src/commonTest/kotlin/ru/alekseev/myapplication/ComposeAppCommonTest.kt",
            "content": "package ru.alekseev.myapplication import kotlin.test.Test import kotlin.test.assertEquals class ComposeAppCommonTest { @Test fun example() { assertEquals(3, 1 + 2) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 19,
            "fileType": "kt"
        },
        {
            "chunkId": "98687ea9-875e-44db-842e-852b3e2bbe3c",
            "filePath": "composeApp/src/iosMain/kotlin/ru/alekseev/myapplication/permissions/PermissionsWrapper.ios.kt",
            "content": "package ru.alekseev.myapplication.permissions import androidx.compose.runtime.Composable import androidx.compose.runtime.remember import dev.icerock.moko.permissions.DeniedAlwaysException import dev.icerock.moko.permissions.DeniedException import dev.icerock.moko.permissions.Permission import dev.icerock.moko.permissions.PermissionsController import dev.icerock.moko.permissions.compose.BindEffect import dev.icerock.moko.permissions.compose.PermissionsControllerFactory import dev.icerock.moko.permissions.compose.rememberPermissionsControllerFactory import dev.icerock.moko.permissions.notifications.REMOTE_NOTIFICATION class MokoPermissionsWrapper( private val controller: PermissionsController ) : PermissionsWrapper { @Composable override fun BindEffect() { BindEffect(controller) } override suspend fun requestNotificationPermission() { try { controller.providePermission(Permission.REMOTE_NOTIFICATION) } catch (e: DeniedException) { throw PermissionDeniedException(\"Permission denied: ${e.message}\") } catch (e: DeniedAlwaysException) { throw PermissionDeniedException(\"Permission denied always: ${e.message}\") } } } @Composable actual fun rememberPermissionsWrapper(): PermissionsWrapper { val factory: PermissionsControllerFactory = rememberPermissionsControllerFactory() val controller: PermissionsController = remember(factory) { factory.createPermissionsController() } return remember(controller) { MokoPermissionsWrapper(controller) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 94,
            "fileType": "kt"
        },
        {
            "chunkId": "92527adf-25be-41a5-b4cd-0375e352f3d1",
            "filePath": "composeApp/src/iosMain/kotlin/ru/alekseev/myapplication/KoinInitializer.kt",
            "content": "package ru.alekseev.myapplication import com.example.myapplication.feature_main.di.featureMainModule import org.koin.core.context.startKoin import org.koin.mp.KoinPlatformTools import ru.alekseev.myapplication.di.platformModule /** * Initialize Koin for iOS platform. * Uses lazy initialization to ensure it's only called once. */ private object KoinInitializer { val isInitialized: Boolean by lazy { startKoin { modules( platformModule, featureMainModule ) } true } } /** * Ensures Koin is initialized. * Safe to call multiple times - will only initialize once. */ fun initKoin() { // Check if Koin is already initialized try { KoinPlatformTools.defaultContext().get() // Already initialized return } catch (_: Exception) { // Not initialized yet, initialize it KoinInitializer.isInitialized } }",
            "startTokenIndex": 0,
            "endTokenIndex": 97,
            "fileType": "kt"
        },
        {
            "chunkId": "9f9ed6dc-5e11-4201-9af8-ab12939f74aa",
            "filePath": "composeApp/src/iosMain/kotlin/ru/alekseev/myapplication/RootViewController.kt",
            "content": "package ru.alekseev.myapplication import androidx.compose.ui.window.ComposeUIViewController import platform.UIKit.UIViewController import androidx.compose.ui.Modifier import androidx.compose.foundation.layout.fillMaxSize import ru.alekseev.myapplication.root.RootContent import ru.alekseev.myapplication.root.RootComponent fun rootViewController(root: RootComponent): UIViewController { // Ensure Koin is initialized initKoin() return ComposeUIViewController { RootContent(component = root, modifier = Modifier.fillMaxSize()) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 36,
            "fileType": "kt"
        },
        {
            "chunkId": "9a6c2bb1-59d1-4d08-aaf7-fe14e7c7099a",
            "filePath": "composeApp/src/jsMain/kotlin/ru/alekseev/myapplication/permissions/PermissionsWrapper.js.kt",
            "content": "package ru.alekseev.myapplication.permissions import androidx.compose.runtime.Composable import androidx.compose.runtime.remember /** * Empty permissions wrapper for JS platform * Notification permissions are not supported on this platform */ class EmptyPermissionsWrapper : PermissionsWrapper { @Composable override fun BindEffect() { // No-op for JS } override suspend fun requestNotificationPermission() { // No-op for JS - permissions not supported } } @Composable actual fun rememberPermissionsWrapper(): PermissionsWrapper { return remember { EmptyPermissionsWrapper() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 66,
            "fileType": "kt"
        },
        {
            "chunkId": "905082a6-bd65-4d60-a31b-989381ac4cf7",
            "filePath": "composeApp/src/jvmMain/kotlin/ru/alekseev/myapplication/permissions/PermissionsWrapper.jvm.kt",
            "content": "package ru.alekseev.myapplication.permissions import androidx.compose.runtime.Composable import androidx.compose.runtime.remember /** * Empty permissions wrapper for JVM platform * Notification permissions are not supported on this platform */ class EmptyPermissionsWrapper : PermissionsWrapper { @Composable override fun BindEffect() { // No-op for JVM } override suspend fun requestNotificationPermission() { // No-op for JVM - permissions not supported } } @Composable actual fun rememberPermissionsWrapper(): PermissionsWrapper { return remember { EmptyPermissionsWrapper() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 66,
            "fileType": "kt"
        },
        {
            "chunkId": "a50d11eb-ead9-4817-8745-c0451d4f0560",
            "filePath": "composeApp/src/jvmMain/kotlin/ru/alekseev/myapplication/Main.kt",
            "content": "package ru.alekseev.myapplication import androidx.compose.ui.window.Window import androidx.compose.ui.window.application import androidx.compose.ui.window.rememberWindowState import com.arkivanov.decompose.DefaultComponentContext import com.arkivanov.decompose.extensions.compose.lifecycle.LifecycleController import com.arkivanov.essenty.lifecycle.LifecycleRegistry import com.example.myapplication.feature_main.di.featureMainModule import org.koin.core.context.startKoin import ru.alekseev.myapplication.di.platformModule import ru.alekseev.myapplication.root.DefaultRootComponent import ru.alekseev.myapplication.root.RootContent fun main() { // Initialize Koin startKoin { modules( platformModule, featureMainModule ) } val lifecycle = LifecycleRegistry() val root = runOnUiThread { DefaultRootComponent( componentContext = DefaultComponentContext(lifecycle = lifecycle), ) } application { val windowState = rememberWindowState() LifecycleController(lifecycle, windowState) Window( onCloseRequest = ::exitApplication, state = windowState, title = \"My Application\" ) { RootContent(root) } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 79,
            "fileType": "kt"
        },
        {
            "chunkId": "c12b36dd-9b39-4d23-8a33-7cb6a91891f8",
            "filePath": "composeApp/src/jvmMain/kotlin/ru/alekseev/myapplication/Utils.kt",
            "content": "package ru.alekseev.myapplication import javax.swing.SwingUtilities internal fun <T> runOnUiThread(block: () -> T): T { if (SwingUtilities.isEventDispatchThread()) { return block() } var error: Throwable? = null var result: T? = null SwingUtilities.invokeAndWait { try { result = block() } catch (e: Throwable) { error = e } } error?.also { throw it } @Suppress(\"UNCHECKED_CAST\") return result as T }",
            "startTokenIndex": 0,
            "endTokenIndex": 57,
            "fileType": "kt"
        },
        {
            "chunkId": "33d2fc99-ca6a-4aa0-8ff6-7e40d115d3e1",
            "filePath": "composeApp/src/wasmJsMain/kotlin/ru/alekseev/myapplication/permissions/PermissionsWrapper.wasmJs.kt",
            "content": "package ru.alekseev.myapplication.permissions import androidx.compose.runtime.Composable import androidx.compose.runtime.remember /** * Empty permissions wrapper for WasmJS platform * Notification permissions are not supported on this platform */ class EmptyPermissionsWrapper : PermissionsWrapper { @Composable override fun BindEffect() { // No-op for WasmJS } override suspend fun requestNotificationPermission() { // No-op for WasmJS - permissions not supported } } @Composable actual fun rememberPermissionsWrapper(): PermissionsWrapper { return remember { EmptyPermissionsWrapper() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 66,
            "fileType": "kt"
        },
        {
            "chunkId": "fd1a37eb-df01-41e6-8cae-2402aa44ff24",
            "filePath": "composeApp/src/webMain/kotlin/ru/alekseev/myapplication/main.kt",
            "content": "package ru.alekseev.myapplication import androidx.compose.ui.ExperimentalComposeUiApi import androidx.compose.ui.window.ComposeViewport import com.arkivanov.decompose.DefaultComponentContext import com.arkivanov.essenty.lifecycle.LifecycleRegistry import com.example.myapplication.feature_main.di.featureMainModule import kotlinx.browser.document import org.koin.core.context.startKoin import ru.alekseev.myapplication.di.platformModule import ru.alekseev.myapplication.root.DefaultRootComponent import ru.alekseev.myapplication.root.RootContent @OptIn(ExperimentalComposeUiApi::class) fun main() { // Initialize Koin startKoin { modules( platformModule, featureMainModule ) } val lifecycle = LifecycleRegistry() val rootComponent = DefaultRootComponent(DefaultComponentContext(lifecycle)) ComposeViewport(document.body!!) { RootContent(component = rootComponent) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 51,
            "fileType": "kt"
        },
        {
            "chunkId": "c60049e8-7acf-402b-a68e-e406a2c844ce",
            "filePath": "composeApp/build.gradle.kts",
            "content": "import org.jetbrains.compose.desktop.application.dsl.TargetFormat import org.jetbrains.kotlin.gradle.ExperimentalWasmDsl import org.jetbrains.kotlin.gradle.dsl.JvmTarget plugins { alias(libs.plugins.kotlinMultiplatform) alias(libs.plugins.androidApplication) alias(libs.plugins.composeMultiplatform) alias(libs.plugins.composeCompiler) alias(libs.plugins.composeHotReload) alias(libs.plugins.kotlinSerialization) } kotlin { applyDefaultHierarchyTemplate() androidTarget { compilerOptions { jvmTarget.set(JvmTarget.fromTarget(libs.versions.jvmTarget.get())) } } listOf( iosArm64(), iosSimulatorArm64() ).forEach { iosTarget -> iosTarget.binaries.framework { baseName = \"ComposeApp\" isStatic = true export(project(\":shared\")) export(libs.decompose.decompose) export(libs.essenty.lifecycle) } } jvm() js { browser() binaries.executable() } @OptIn(ExperimentalWasmDsl::class) wasmJs { browser() binaries.executable() } sourceSets { commonMain.dependencies { implementation(compose.runtime) implementation(compose.foundation) implementation(compose.material3) implementation(libs.compose.material.iconsCore) implementation(libs.compose.material.iconsExtended) implementation(compose.ui) implementation(compose.components.resources) implementation(compose.components.uiToolingPreview) implementation(libs.androidx.lifecycle.viewmodelCompose) implementation(libs.androidx.lifecycle.runtimeCompose) api(projects.shared) // Decompose Libraries api(libs.decompose.decompose) api(libs.essenty.lifecycle) implementation(libs.decompose.extensionsComposeJetbrains) // FlowMVI implementation(libs.flowmvi.core) implementation(libs.flowmvi.compose) // Koin implementation(libs.koin.core) implementation(libs.koin.compose) // Feature modules implementation(project(\":feature-main\")) implementation(project(\":feature-welcome\")) } androidMain.dependencies { implementation(compose.preview) implementation(libs.androidx.activity.compose) implementation(libs.koin.android) //Permission-compose (only for Android and iOS) api(libs.permissions.compose) api(libs.permissions) implementation(libs.permissions.notifications) } val iosMain by getting { dependencies { //Permission-compose (only for Android and iOS) api(libs.permissions.compose) api(libs.permissions) implementation(libs.permissions.notifications) } } jvmMain.dependencies { implementation(compose.desktop.currentOs) implementation(libs.kotlinx.coroutinesSwing) } commonTest.dependencies { implementation(libs.kotlin.test) } } } android { namespace = \"ru.alekseev.myapplication\" compileSdk = libs.versions.android.compileSdk.get().toInt() defaultConfig { applicationId = \"ru.alekseev.myapplication\" minSdk = libs.versions.android.minSdk.get().toInt() targetSdk = libs.versions.android.targetSdk.get().toInt() versionCode = 1 versionName = \"1.0\" } packaging { resources { excludes += \"/META-INF/{AL2.0,LGPL2.1}\" } } buildTypes { getByName(\"release\") { isMinifyEnabled = false } } compileOptions { val jvmTargetVersion = libs.versions.jvmTarget.get().toInt() sourceCompatibility = JavaVersion.toVersion(jvmTargetVersion) targetCompatibility = JavaVersion.toVersion(jvmTargetVersion) } } dependencies { debugImplementation(compose.uiTooling) } compose.desktop { application { mainClass = \"ru.alekseev.myapplication.MainKt\" nativeDistributions { targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb) packageName = \"ru.alekseev.myapplication\" packageVersion = \"1.0.0\" } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 219,
            "fileType": "kts"
        },
        {
            "chunkId": "f603ce1f-d77c-4517-a398-beda4ad58a11",
            "filePath": "core-common/src/androidMain/kotlin/ru/alekseev/myapplication/core/common/Constants.android.kt",
            "content": "package ru.alekseev.myapplication.core.common /** * Server host configuration for Android * * Choose one based on your setup: * - Android Emulator: \"10.0.2.2\" (special IP to access host machine) * - Physical Device / Network: \"192.168.0.14\" (host machine IP in local network) * * To find your host machine IP: * - macOS/Linux: ifconfig | grep \"inet \" | grep -v 127.0.0.1 * - Windows: ipconfig */ actual val SERVER_HOST: String = \"192.168.0.18\" // Physical device // actual val SERVER_HOST: String = \"10.0.2.2\" // Emulator",
            "startTokenIndex": 0,
            "endTokenIndex": 84,
            "fileType": "kt"
        },
        {
            "chunkId": "c10ae33d-0b31-4926-a0e7-76432e6f7e9c",
            "filePath": "core-common/src/commonMain/kotlin/ru/alekseev/myapplication/core/common/Constants.kt",
            "content": "Error: Cannot read binary file: Constants.kt",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "kt"
        },
        {
            "chunkId": "c9cb2ca0-e7a8-4eed-9641-90056ea746c1",
            "filePath": "core-common/src/commonMain/kotlin/ru/alekseev/myapplication/core/common/JsonFactory.kt",
            "content": "package ru.alekseev.myapplication.core.common import kotlinx.serialization.json.Json /** * Factory for creating configured Json instances with consistent settings across the application. * This ensures all JSON serialization/deserialization uses the same configuration. */ object JsonFactory { /** * Creates a Json instance with standard application-wide configuration: * - classDiscriminator = \"type\" for polymorphic serialization * - ignoreUnknownKeys = true for backward compatibility * - prettyPrint = true for readable output * - isLenient = true for relaxed parsing * - encodeDefaults = true to include default values */ fun create(): Json = Json { classDiscriminator = \"type\" ignoreUnknownKeys = true prettyPrint = true isLenient = true encodeDefaults = true } }",
            "startTokenIndex": 0,
            "endTokenIndex": 107,
            "fileType": "kt"
        },
        {
            "chunkId": "ef00fcb1-31a6-4d2c-9aaf-0470ccfb0ba7",
            "filePath": "core-common/src/iosMain/kotlin/ru/alekseev/myapplication/core/common/Constants.ios.kt",
            "content": "package ru.alekseev.myapplication.core.common actual val SERVER_HOST: String = \"localhost\"",
            "startTokenIndex": 0,
            "endTokenIndex": 8,
            "fileType": "kt"
        },
        {
            "chunkId": "020f240e-94cd-4300-81b4-e20764908055",
            "filePath": "core-common/src/jsMain/kotlin/ru/alekseev/myapplication/core/common/Constants.js.kt",
            "content": "package ru.alekseev.myapplication.core.common actual val SERVER_HOST: String = \"localhost\"",
            "startTokenIndex": 0,
            "endTokenIndex": 8,
            "fileType": "kt"
        },
        {
            "chunkId": "fde43c0d-83b1-464f-a9cd-c2db5368e356",
            "filePath": "core-common/src/jvmMain/kotlin/ru/alekseev/myapplication/core/common/Constants.jvm.kt",
            "content": "package ru.alekseev.myapplication.core.common actual val SERVER_HOST: String = \"localhost\"",
            "startTokenIndex": 0,
            "endTokenIndex": 8,
            "fileType": "kt"
        },
        {
            "chunkId": "fd024df6-ee4e-4385-92a5-ede04f2b8456",
            "filePath": "core-common/src/wasmJsMain/kotlin/ru/alekseev/myapplication/core/common/Constants.wasmJs.kt",
            "content": "package ru.alekseev.myapplication.core.common actual val SERVER_HOST: String = \"localhost\"",
            "startTokenIndex": 0,
            "endTokenIndex": 8,
            "fileType": "kt"
        },
        {
            "chunkId": "912dde7e-76f9-48e4-a5db-b37e80e6d4ed",
            "filePath": "core-common/build.gradle.kts",
            "content": "import org.jetbrains.kotlin.gradle.ExperimentalWasmDsl import org.jetbrains.kotlin.gradle.dsl.JvmTarget plugins { alias(libs.plugins.kotlinMultiplatform) alias(libs.plugins.androidLibrary) alias(libs.plugins.kotlinSerialization) } kotlin { applyDefaultHierarchyTemplate() androidTarget { compilerOptions { jvmTarget.set(JvmTarget.fromTarget(libs.versions.jvmTarget.get())) } } jvm() js { browser() binaries.library() } @OptIn(ExperimentalWasmDsl::class) wasmJs { browser() binaries.library() } iosArm64() iosSimulatorArm64() sourceSets { commonMain.dependencies { implementation(libs.serialization.json) } } } android { namespace = \"ru.alekseev.myapplication.core.common\" compileSdk = libs.versions.android.compileSdk.get().toInt() defaultConfig { minSdk = libs.versions.android.minSdk.get().toInt() } compileOptions { val jvmTargetVersion = libs.versions.jvmTarget.get().toInt() sourceCompatibility = JavaVersion.toVersion(jvmTargetVersion) targetCompatibility = JavaVersion.toVersion(jvmTargetVersion) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 70,
            "fileType": "kts"
        },
        {
            "chunkId": "af3b2f83-109f-4652-83cc-ce15cb49e2d3",
            "filePath": "core-network/src/commonMain/kotlin/ru/alekseev/myapplication/core/network/dto/ChatDto.kt",
            "content": "@file:OptIn(ExperimentalTime::class) package ru.alekseev.myapplication.core.network.dto import kotlinx.serialization.ExperimentalSerializationApi import kotlinx.serialization.SerialName import kotlinx.serialization.Serializable import kotlinx.serialization.json.JsonClassDiscriminator import kotlin.time.Clock import kotlin.time.ExperimentalTime /** * DTO for communication between frontend and backend via WebSocket * This DTO is used both on client and server side */ @Serializable data class ChatMessageDto( val id: String, val content: String, val sender: MessageSender, val timestamp: Long = Clock.System.now().toEpochMilliseconds(), val messageInfo: MessageInfoDto? = null ) @Serializable enum class MessageSender { USER, ASSISTANT } @Serializable data class ChatRequestDto( val message: String ) @OptIn(ExperimentalSerializationApi::class) @Serializable @JsonClassDiscriminator(\"type\") sealed interface ChatResponseDto { @Serializable @SerialName(\"loading\") data object Loading : ChatResponseDto @Serializable @SerialName(\"data\") data class Data(val message: ChatMessageDto) : ChatResponseDto @Serializable @SerialName(\"error\") data class Error(val error: String) : ChatResponseDto @Serializable @SerialName(\"history\") data class History(val messages: List<ChatMessageDto>) : ChatResponseDto } @Serializable data class MessageInfoDto( val inputTokens: Int, val outputTokens: Int, val responseTimeMs: Long, val model: String, val cost: Double )",
            "startTokenIndex": 0,
            "endTokenIndex": 140,
            "fileType": "kt"
        },
        {
            "chunkId": "b525fbd1-eb4e-414d-bd95-589fbb3a22d7",
            "filePath": "core-network/src/commonMain/kotlin/ru/alekseev/myapplication/core/network/dto/ClaudeApiDto.kt",
            "content": "package ru.alekseev.myapplication.core.network.dto import kotlinx.serialization.SerialName import kotlinx.serialization.Serializable @Serializable data class ClaudeRequest( val model: String = \"claude-haiku-4-5-20251001\", // claude-sonnet-4-5-20250929 @SerialName(\"max_tokens\") val maxTokens: Int = 1024, val messages: List<ClaudeMessage>, val stream: Boolean = false, ) @Serializable data class ClaudeMessage( val role: String, // \"user\" or \"assistant\" val content: String, ) @Serializable data class ClaudeResponse( val id: String? = null, val type: String? = null, val role: String? = null, val content: List<ClaudeContent>? = null, val model: String? = null, @SerialName(\"stop_reason\") val stopReason: String? = null, @SerialName(\"stop_sequence\") val stopSequence: String? = null, val usage: ClaudeUsage? = null, ) @Serializable data class ClaudeContent( val type: String, val text: String? = null, ) @Serializable data class ClaudeUsage( @SerialName(\"input_tokens\") val inputTokens: Int, @SerialName(\"output_tokens\") val outputTokens: Int, )",
            "startTokenIndex": 0,
            "endTokenIndex": 120,
            "fileType": "kt"
        },
        {
            "chunkId": "9ae6e105-0f42-4574-b83d-221a7a33182d",
            "filePath": "core-network/build.gradle.kts",
            "content": "import org.jetbrains.kotlin.gradle.ExperimentalWasmDsl import org.jetbrains.kotlin.gradle.dsl.JvmTarget plugins { alias(libs.plugins.kotlinMultiplatform) alias(libs.plugins.androidLibrary) alias(libs.plugins.kotlinSerialization) } kotlin { applyDefaultHierarchyTemplate() androidTarget { compilerOptions { jvmTarget.set(JvmTarget.fromTarget(libs.versions.jvmTarget.get())) } } jvm() js { browser() binaries.library() } @OptIn(ExperimentalWasmDsl::class) wasmJs { browser() binaries.library() } iosArm64() iosSimulatorArm64() sourceSets { val commonMain by getting { dependencies { // Serialization implementation(libs.serialization.json) } } val androidMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.android) } } val jvmMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.cio) } } val iosMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.darwin) } } val jsMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.js) } } val wasmJsMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.js) } } } } android { namespace = \"ru.alekseev.myapplication.core.network\" compileSdk = libs.versions.android.compileSdk.get().toInt() defaultConfig { minSdk = libs.versions.android.minSdk.get().toInt() } compileOptions { val jvmTargetVersion = libs.versions.jvmTarget.get().toInt() sourceCompatibility = JavaVersion.toVersion(jvmTargetVersion) targetCompatibility = JavaVersion.toVersion(jvmTargetVersion) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 148,
            "fileType": "kts"
        },
        {
            "chunkId": "3e7ff480-ee02-4cf3-9266-fcac6d212003",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/data/mapper/ChatMapper.kt",
            "content": "package com.example.myapplication.feature_main.data.mapper import com.example.myapplication.feature_main.domain.entity.AlertEntity import com.example.myapplication.feature_main.domain.entity.AlertSeverity import com.example.myapplication.feature_main.domain.entity.ChatMessage import com.example.myapplication.feature_main.domain.entity.MessageInfo import ru.alekseev.myapplication.data.dto.AlertSeverityDto import ru.alekseev.myapplication.data.dto.ChatMessageDto import ru.alekseev.myapplication.data.dto.MessageInfoDto import ru.alekseev.myapplication.data.dto.MessageSender import ru.alekseev.myapplication.data.dto.UserAlertDto // MessageInfo mappers fun MessageInfoDto.toDomain(): MessageInfo { return MessageInfo( inputTokens = inputTokens, outputTokens = outputTokens, responseTimeMs = responseTimeMs, model = model, cost = cost ) } fun MessageInfo.toDto(): MessageInfoDto { return MessageInfoDto( inputTokens = inputTokens, outputTokens = outputTokens, responseTimeMs = responseTimeMs, model = model, cost = cost ) } // ChatMessage mappers fun ChatMessageDto.toDomain(): ChatMessage { return ChatMessage( id = id, content = content, isFromUser = sender == MessageSender.USER, timestamp = timestamp, messageInfo = messageInfo?.toDomain() ) } fun ChatMessage.toDto(): ChatMessageDto { return ChatMessageDto( id = id, content = content, sender = if (isFromUser) MessageSender.USER else MessageSender.ASSISTANT, timestamp = timestamp, messageInfo = messageInfo?.toDto() ) } fun UserAlertDto.toDomain(): AlertEntity { return AlertEntity( id = id, title = title, message = message, severity = when (severity) { AlertSeverityDto.INFO -> AlertSeverity.INFO AlertSeverityDto.WARNING -> AlertSeverity.WARNING AlertSeverityDto.ERROR -> AlertSeverity.ERROR AlertSeverityDto.SUCCESS -> AlertSeverity.SUCCESS }, timestamp = timestamp, category = category, actionLabel = actionLabel, actionData = actionData ) } fun AlertEntity.toDto(): UserAlertDto { return UserAlertDto( id = id, title = title, message = message, severity = when (severity) { AlertSeverity.INFO -> AlertSeverityDto.INFO AlertSeverity.WARNING -> AlertSeverityDto.WARNING AlertSeverity.ERROR -> AlertSeverityDto.ERROR AlertSeverity.SUCCESS -> AlertSeverityDto.SUCCESS }, timestamp = timestamp, category = category, actionLabel = actionLabel, actionData = actionData ) }",
            "startTokenIndex": 0,
            "endTokenIndex": 218,
            "fileType": "kt"
        },
        {
            "chunkId": "15b98615-d1ff-4b23-a315-de5db3260164",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/data/repository/ChatRepositoryImpl.kt",
            "content": "package com.example.myapplication.feature_main.data.repository import com.example.myapplication.feature_main.data.mapper.toDomain import com.example.myapplication.feature_main.domain.entity.ChatMessageState import com.example.myapplication.feature_main.domain.repository.ChatRepository import com.example.myapplication.feature_main.domain.usecase.DispatchAlertUseCase import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.map import ru.alekseev.myapplication.data.datasource.ChatWebSocketDataSource import ru.alekseev.myapplication.data.dto.ChatResponseDto class ChatRepositoryImpl( private val webSocketDataSource: ChatWebSocketDataSource, private val dispatchAlertUseCase: DispatchAlertUseCase, ) : ChatRepository { override suspend fun sendMessage(message: String) { webSocketDataSource.sendMessage(message) } override fun observeMessages(): Flow<Result<ChatMessageState>> { return webSocketDataSource.observeMessages().map { response -> when (response) { is ChatResponseDto.Error -> Result.failure(Exception(response.error)) is ChatResponseDto.Data -> Result.success( ChatMessageState.Data(response.message.toDomain()) ) is ChatResponseDto.Loading -> Result.success(ChatMessageState.Loading) is ChatResponseDto.History -> Result.success( ChatMessageState.History(response.messages.map { it.toDomain() }) ) is ChatResponseDto.Alert -> { val domainAlert = response.alert.toDomain() dispatchAlertUseCase(domainAlert) Result.success(ChatMessageState.Alert(domainAlert)) } } } } override suspend fun connect() { webSocketDataSource.connect() } override suspend fun disconnect() { webSocketDataSource.disconnect() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 105,
            "fileType": "kt"
        },
        {
            "chunkId": "56b6e2ee-84f4-49f3-8534-59908bd7871e",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/di/FeatureMainModule.kt",
            "content": "package com.example.myapplication.feature_main.di import com.example.myapplication.feature_main.data.repository.ChatRepositoryImpl import com.example.myapplication.feature_main.domain.repository.ChatRepository import com.example.myapplication.feature_main.domain.usecase.ConnectToChatUseCase import com.example.myapplication.feature_main.domain.usecase.DispatchAlertUseCase import com.example.myapplication.feature_main.domain.usecase.ObserveMessagesUseCase import com.example.myapplication.feature_main.domain.usecase.SendMessageUseCase import com.example.myapplication.feature_main.presentation.ChatStore import org.koin.core.module.dsl.factoryOf import org.koin.core.module.dsl.singleOf import org.koin.dsl.bind import org.koin.dsl.module import ru.alekseev.myapplication.core.common.JsonFactory import ru.alekseev.myapplication.data.datasource.ChatWebSocketDataSource import ru.alekseev.myapplication.data.datasource.ChatWebSocketDataSourceImpl val featureMainModule = module { // Json serializer single { JsonFactory.create() } // Data Source from shared singleOf(::ChatWebSocketDataSourceImpl) bind ChatWebSocketDataSource::class // Repository singleOf(::ChatRepositoryImpl) bind ChatRepository::class // Use Cases factoryOf(::SendMessageUseCase) factoryOf(::ObserveMessagesUseCase) factoryOf(::ConnectToChatUseCase) factoryOf(::DispatchAlertUseCase) // Store factoryOf(::ChatStore) }",
            "startTokenIndex": 0,
            "endTokenIndex": 66,
            "fileType": "kt"
        },
        {
            "chunkId": "c4e1af49-e710-4f75-854c-c2fc1fc22a1f",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/entity/AlertEntity.kt",
            "content": "package com.example.myapplication.feature_main.domain.entity /** * Domain entity representing a user alert/notification */ data class AlertEntity( val id: String, val title: String, val message: String, val severity: AlertSeverity, val timestamp: Long, val category: String? = null, val actionLabel: String? = null, val actionData: String? = null ) enum class AlertSeverity { INFO, WARNING, ERROR, SUCCESS }",
            "startTokenIndex": 0,
            "endTokenIndex": 54,
            "fileType": "kt"
        },
        {
            "chunkId": "d3343bef-579f-497c-b8e5-1b9a7d44a058",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/entity/ChatMessage.kt",
            "content": "package com.example.myapplication.feature_main.domain.entity data class ChatMessage( val id: String, val content: String, val isFromUser: Boolean, val timestamp: Long, val messageInfo: MessageInfo? = null ) sealed interface ChatMessageState { data object Loading : ChatMessageState data class Data(val message: ChatMessage) : ChatMessageState data class History(val messages: List<ChatMessage>) : ChatMessageState data class Alert(val alert: AlertEntity) : ChatMessageState }",
            "startTokenIndex": 0,
            "endTokenIndex": 54,
            "fileType": "kt"
        },
        {
            "chunkId": "ede6c279-27dc-42fa-8b4a-734f68b0e943",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/entity/MessageInfo.kt",
            "content": "package com.example.myapplication.feature_main.domain.entity import kotlinx.serialization.Serializable /** * Domain model for message metadata/info * This is used in the domain and presentation layers */ @Serializable data class MessageInfo( val inputTokens: Int, val outputTokens: Int, val responseTimeMs: Long, val model: String, val cost: Double )",
            "startTokenIndex": 0,
            "endTokenIndex": 42,
            "fileType": "kt"
        },
        {
            "chunkId": "ac8670f9-62c9-472a-b66c-6274b54328c0",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/repository/ChatRepository.kt",
            "content": "package com.example.myapplication.feature_main.domain.repository import com.example.myapplication.feature_main.domain.entity.ChatMessageState import kotlinx.coroutines.flow.Flow interface ChatRepository { suspend fun sendMessage(message: String) fun observeMessages(): Flow<Result<ChatMessageState>> suspend fun connect() suspend fun disconnect() }",
            "startTokenIndex": 0,
            "endTokenIndex": 23,
            "fileType": "kt"
        },
        {
            "chunkId": "768580fa-cbc1-46d9-8f15-4cea1f4ca1bf",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/usecase/ConnectToChatUseCase.kt",
            "content": "package com.example.myapplication.feature_main.domain.usecase import com.example.myapplication.feature_main.domain.repository.ChatRepository class ConnectToChatUseCase( private val chatRepository: ChatRepository ) { suspend operator fun invoke() { chatRepository.connect() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 20,
            "fileType": "kt"
        },
        {
            "chunkId": "78f715e9-5dfd-4a00-8163-5c563fe9a3e4",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/usecase/DispatchAlertUseCase.kt",
            "content": "package com.example.myapplication.feature_main.domain.usecase import com.example.myapplication.feature_main.data.mapper.toDto import com.example.myapplication.feature_main.domain.entity.AlertEntity import ru.alekseev.myapplication.service.AlertDispatcher /** * Use case for dispatching alerts to the user using platform-specific AlertDispatcher */ class DispatchAlertUseCase( private val alertDispatcher: AlertDispatcher ) { suspend operator fun invoke(alert: AlertEntity) { // Convert domain Alert to DTO UserAlert for platform dispatcher val userAlert = alert.toDto() // Dispatch the alert using platform-specific implementation alertDispatcher.dispatch(userAlert) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 60,
            "fileType": "kt"
        },
        {
            "chunkId": "b6485937-8fb4-49c8-8fad-e5f419c8faa2",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/usecase/ObserveMessagesUseCase.kt",
            "content": "package com.example.myapplication.feature_main.domain.usecase import com.example.myapplication.feature_main.domain.entity.ChatMessageState import com.example.myapplication.feature_main.domain.repository.ChatRepository import kotlinx.coroutines.flow.Flow class ObserveMessagesUseCase( private val chatRepository: ChatRepository ) { operator fun invoke(): Flow<Result<ChatMessageState>> { return chatRepository.observeMessages() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 25,
            "fileType": "kt"
        },
        {
            "chunkId": "14a11e71-7ce0-445e-aedd-b06eeefbdeca",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/domain/usecase/SendMessageUseCase.kt",
            "content": "package com.example.myapplication.feature_main.domain.usecase import com.example.myapplication.feature_main.domain.repository.ChatRepository class SendMessageUseCase( private val chatRepository: ChatRepository ) { suspend operator fun invoke(message: String) { if (message.isBlank()) { throw IllegalArgumentException(\"Message cannot be empty\") } chatRepository.sendMessage(message) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 30,
            "fileType": "kt"
        },
        {
            "chunkId": "01fc8481-b34d-44c6-847d-6a899619d784",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/presentation/messageinfo/DefaultMessageInfoComponent.kt",
            "content": "package com.example.myapplication.feature_main.presentation.messageinfo import com.arkivanov.decompose.ComponentContext import com.example.myapplication.feature_main.domain.entity.MessageInfo import ru.alekseev.myapplication.data.dto.MessageInfoDto class DefaultMessageInfoComponent( componentContext: ComponentContext, override val messageInfo: MessageInfo, private val onDismissRequested: () -> Unit ) : MessageInfoComponent, ComponentContext by componentContext { override fun onDismiss() { onDismissRequested() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 36,
            "fileType": "kt"
        },
        {
            "chunkId": "87daec34-8d4b-45d4-8a69-f04e9b1ca00a",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/presentation/messageinfo/MessageInfoComponent.kt",
            "content": "package com.example.myapplication.feature_main.presentation.messageinfo import com.example.myapplication.feature_main.domain.entity.MessageInfo interface MessageInfoComponent { val messageInfo: MessageInfo fun onDismiss() }",
            "startTokenIndex": 0,
            "endTokenIndex": 13,
            "fileType": "kt"
        },
        {
            "chunkId": "1f6f985c-c4f9-494f-83d0-8b212a2643c8",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/presentation/ChatStore.kt",
            "content": "@file:OptIn(ExperimentalUuidApi::class, ExperimentalTime::class) package com.example.myapplication.feature_main.presentation import com.example.myapplication.feature_main.domain.entity.AlertEntity import com.example.myapplication.feature_main.domain.entity.ChatMessage import com.example.myapplication.feature_main.domain.entity.ChatMessageState import com.example.myapplication.feature_main.domain.usecase.ConnectToChatUseCase import com.example.myapplication.feature_main.domain.usecase.ObserveMessagesUseCase import com.example.myapplication.feature_main.domain.usecase.SendMessageUseCase import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.flow.launchIn import kotlinx.coroutines.flow.onEach import pro.respawn.flowmvi.api.Container import pro.respawn.flowmvi.api.MVIAction import pro.respawn.flowmvi.api.MVIIntent import pro.respawn.flowmvi.api.MVIState import pro.respawn.flowmvi.api.Store import pro.respawn.flowmvi.dsl.store import pro.respawn.flowmvi.plugins.init import pro.respawn.flowmvi.plugins.recover import pro.respawn.flowmvi.plugins.reduce import kotlin.time.Clock import kotlin.time.ExperimentalTime import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid data class ChatState( val messages: List<ChatMessage> = emptyList(), val currentMessage: String = \"\", val error: String? = null, val isLoading: Boolean = false ) : MVIState sealed interface ChatIntent : MVIIntent { data class SendMessage(val message: String) : ChatIntent data class UpdateMessageText(val text: String) : ChatIntent data object ClearError : ChatIntent data object Connect : ChatIntent } sealed interface ChatAction : MVIAction { data class ShowError(val message: String) : ChatAction data class ShowAlert(val alert: AlertEntity) : ChatAction } class ChatStore( private val sendMessageUseCase: SendMessageUseCase, private val observeMessagesUseCase: ObserveMessagesUseCase, private val connectToChatUseCase: ConnectToChatUseCase, ) : Container<ChatState, ChatIntent, ChatAction> { override val store: Store<ChatState, ChatIntent, ChatAction> = store(ChatState()) { configure { debuggable = true parallelIntents = true this@store.recover { exception -> updateState { copy(error = exception.message) } null } } init { // Connect to chat on start connectToChatUseCase() // Observe messages observeMessagesUseCase().onEach { result -> result.onSuccess { messageState -> updateState { when (messageState) { is ChatMessageState.Loading -> { copy( isLoading = true, ) } is ChatMessageState.Data -> { copy( messages = messages + messageState.message, isLoading = false ) } is ChatMessageState.History -> { copy( messages = messageState.messages ) } is ChatMessageState.Alert -> { action(ChatAction.ShowAlert(messageState.alert)) this } } } }.onFailure { error -> updateState { copy( error = error.message ) } action(ChatAction.ShowError(error.message ?: \"Unknown error\")) } }.launchIn(CoroutineScope(coroutineContext)) } reduce { intent -> when (intent) { is ChatIntent.UpdateMessageText -> updateState { copy(currentMessage = intent.text, error = null) } is ChatIntent.SendMessage -> { val messageText = intent.message.trim() if (messageText.isEmpty()) return@reduce // Add user message immediately val userMessage = ChatMessage( id = Uuid.random().toString(), content = messageText, isFromUser = true, timestamp = Clock.System.now().toEpochMilliseconds(), ) updateState { copy( messages = messages, currentMessage = \"\", error = null ) } // Send message to server sendMessageUseCase(messageText) } is ChatIntent.ClearError -> updateState { copy(error = null) } is ChatIntent.Connect -> { connectToChatUseCase() } } } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 356,
            "fileType": "kt"
        },
        {
            "chunkId": "15b36b38-1c2f-4aa2-be39-010cb9974e81",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/presentation/DefaultMainComponent.kt",
            "content": "package com.example.myapplication.feature_main.presentation import com.arkivanov.decompose.ComponentContext import com.arkivanov.decompose.router.slot.ChildSlot import com.arkivanov.decompose.router.slot.SlotNavigation import com.arkivanov.decompose.router.slot.activate import com.arkivanov.decompose.router.slot.childSlot import com.arkivanov.decompose.router.slot.dismiss import com.arkivanov.decompose.value.Value import com.arkivanov.essenty.lifecycle.doOnDestroy import com.example.myapplication.feature_main.domain.entity.ChatMessage import com.example.myapplication.feature_main.domain.entity.MessageInfo import com.example.myapplication.feature_main.presentation.messageinfo.DefaultMessageInfoComponent import com.example.myapplication.feature_main.presentation.messageinfo.MessageInfoComponent import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.SupervisorJob import kotlinx.coroutines.cancel import kotlinx.coroutines.launch import kotlinx.serialization.Serializable import org.koin.core.component.KoinComponent import org.koin.core.component.inject import pro.respawn.flowmvi.api.Store class DefaultMainComponent( componentContext: ComponentContext, ) : MainComponent, ComponentContext by componentContext, KoinComponent { private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main) private val chatStore: ChatStore by inject() override val state: Store<ChatState, ChatIntent, ChatAction> = chatStore.store private val messageInfoNavigation = SlotNavigation<MessageInfoConfig>() override val messageInfoSlot: Value<ChildSlot<*, MessageInfoComponent>> = childSlot( source = messageInfoNavigation, serializer = MessageInfoConfig.serializer(), handleBackButton = true ) { config, childComponentContext -> DefaultMessageInfoComponent( componentContext = childComponentContext, messageInfo = config.messageInfo, onDismissRequested = ::dismissMessageInfo ) } init { lifecycle.doOnDestroy { scope.cancel() state.close() } scope.launch { state.start(scope) } } @Serializable private data class MessageInfoConfig( val messageInfo: MessageInfo, ) override fun onSendMessage(message: String) { scope.launch { state.emit(ChatIntent.SendMessage(message)) } } override fun onMessageTextChanged(text: String) { scope.launch(Dispatchers.Unconfined) { state.emit(ChatIntent.UpdateMessageText(text)) } } override fun onClearError() { scope.launch { state.emit(ChatIntent.ClearError) } } override fun onMessageClick(message: ChatMessage) { message.messageInfo?.let { info -> messageInfoNavigation.activate(MessageInfoConfig(info)) } } private fun dismissMessageInfo() { messageInfoNavigation.dismiss() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 184,
            "fileType": "kt"
        },
        {
            "chunkId": "bf36c6ef-f1b0-42d3-828e-fae0978669dd",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/presentation/MainComponent.kt",
            "content": "package com.example.myapplication.feature_main.presentation import com.arkivanov.decompose.router.slot.ChildSlot import com.arkivanov.decompose.value.Value import com.example.myapplication.feature_main.domain.entity.ChatMessage import com.example.myapplication.feature_main.presentation.messageinfo.MessageInfoComponent import pro.respawn.flowmvi.api.Store interface MainComponent { val state: Store<ChatState, ChatIntent, ChatAction> val messageInfoSlot: Value<ChildSlot<*, MessageInfoComponent>> fun onSendMessage(message: String) fun onMessageTextChanged(text: String) fun onClearError() fun onMessageClick(message: ChatMessage) }",
            "startTokenIndex": 0,
            "endTokenIndex": 36,
            "fileType": "kt"
        },
        {
            "chunkId": "871e8ed9-c8e5-4775-ab9a-b1786bc7c871",
            "filePath": "feature-main/src/commonMain/kotlin/com/example/myapplication/feature_main/presentation/PreviewMainComponent.kt",
            "content": "package com.example.myapplication.feature_main.presentation import com.arkivanov.decompose.router.slot.ChildSlot import com.arkivanov.decompose.value.MutableValue import com.arkivanov.decompose.value.Value import com.example.myapplication.feature_main.domain.entity.ChatMessage import com.example.myapplication.feature_main.presentation.messageinfo.MessageInfoComponent import pro.respawn.flowmvi.api.Store import pro.respawn.flowmvi.dsl.store object PreviewMainComponent : MainComponent { override val state: Store<ChatState, ChatIntent, ChatAction> = store(ChatState()) { } override val messageInfoSlot: Value<ChildSlot<*, MessageInfoComponent>> = MutableValue( ChildSlot<Unit, MessageInfoComponent>(child = null) ) override fun onSendMessage(message: String) {} override fun onMessageTextChanged(text: String) {} override fun onClearError() {} override fun onMessageClick(message: ChatMessage) {} }",
            "startTokenIndex": 0,
            "endTokenIndex": 63,
            "fileType": "kt"
        },
        {
            "chunkId": "988a967c-de27-44c6-b269-cdae028abef6",
            "filePath": "feature-main/build.gradle.kts",
            "content": "@file:Suppress(\"DSL_SCOPE_VIOLATION\") import org.jetbrains.kotlin.gradle.ExperimentalWasmDsl import org.jetbrains.kotlin.gradle.dsl.JvmTarget plugins { alias(libs.plugins.kotlinMultiplatform) alias(libs.plugins.kotlinSerialization) } kotlin { applyDefaultHierarchyTemplate() jvm() js { browser() binaries.library() } @OptIn(ExperimentalWasmDsl::class) wasmJs { browser() binaries.library() } iosArm64() iosSimulatorArm64() sourceSets { val commonMain by getting { dependencies { // Core api(project(\":shared\")) api(project(\":core-common\")) // Decompose api(libs.decompose.decompose) api(libs.essenty.lifecycle) // FlowMVI implementation(libs.flowmvi.core) // Koin implementation(libs.koin.core) // Coroutines implementation(libs.kotlinx.coroutines) // Serialization implementation(libs.serialization.json) //DateTime implementation(libs.kotlinx.datetime) } } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 62,
            "fileType": "kts"
        },
        {
            "chunkId": "02cd8c5d-e040-4b07-a482-5f1bc26a071e",
            "filePath": "feature-welcome/src/commonMain/kotlin/com/example/myapplication/feature_welcome/presentation/DefaultWelcomeComponent.kt",
            "content": "package com.example.myapplication.feature_welcome.presentation import com.arkivanov.decompose.ComponentContext import com.arkivanov.decompose.value.MutableValue import com.arkivanov.decompose.value.Value import com.arkivanov.decompose.value.update import com.example.myapplication.feature_welcome.presentation.WelcomeComponent.Model import ru.alekseev.myapplication.getPlatform class DefaultWelcomeComponent( private val componentContext: ComponentContext, private val onFinished: () -> Unit, ) : WelcomeComponent, ComponentContext by componentContext { // Consider preserving and managing the state via a store private val state = MutableValue(Model()) override val model: Value<Model> = state override fun onUpdateGreetingText() { state.update { it.copy(greetingText = \"Welcome from ${getPlatform().name}\") } } override fun onBackClicked() { onFinished() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 74,
            "fileType": "kt"
        },
        {
            "chunkId": "0ec218b2-1d39-4cda-abe3-dd2532feba6e",
            "filePath": "feature-welcome/src/commonMain/kotlin/com/example/myapplication/feature_welcome/presentation/PreviewWelcomeComponent.kt",
            "content": "package com.example.myapplication.feature_welcome.presentation import com.arkivanov.decompose.value.MutableValue import com.example.myapplication.feature_welcome.presentation.WelcomeComponent.Model object PreviewWelcomeComponent : WelcomeComponent { override val model = MutableValue(Model()) override fun onUpdateGreetingText() {} override fun onBackClicked() {} }",
            "startTokenIndex": 0,
            "endTokenIndex": 25,
            "fileType": "kt"
        },
        {
            "chunkId": "9ef8fa60-cb7b-48b3-bda8-3338062d3f3d",
            "filePath": "feature-welcome/src/commonMain/kotlin/com/example/myapplication/feature_welcome/presentation/WelcomeComponent.kt",
            "content": "package com.example.myapplication.feature_welcome.presentation import com.arkivanov.decompose.value.Value interface WelcomeComponent { val model: Value<Model> fun onUpdateGreetingText() fun onBackClicked() data class Model( val greetingText: String = \"Welcome from Decompose!\" ) }",
            "startTokenIndex": 0,
            "endTokenIndex": 26,
            "fileType": "kt"
        },
        {
            "chunkId": "9a183bc1-6074-4846-93c7-a7039af10cf9",
            "filePath": "feature-welcome/build.gradle.kts",
            "content": "@file:Suppress(\"DSL_SCOPE_VIOLATION\") import org.jetbrains.kotlin.gradle.ExperimentalWasmDsl plugins { alias(libs.plugins.kotlinMultiplatform) } kotlin { applyDefaultHierarchyTemplate() jvm() js { browser() binaries.library() } @OptIn(ExperimentalWasmDsl::class) wasmJs { browser() binaries.library() } iosArm64() iosSimulatorArm64() sourceSets { val commonMain by getting { dependencies { // Core api(project(\":shared\")) // Decompose api(libs.decompose.decompose) api(libs.essenty.lifecycle) // FlowMVI implementation(libs.flowmvi.core) // Koin implementation(libs.koin.core) // Coroutines implementation(libs.kotlinx.coroutines) } } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 53,
            "fileType": "kts"
        },
        {
            "chunkId": "c9aee3bc-0660-4de7-b47b-43867d3b6b70",
            "filePath": "mcp-server/src/main/kotlin/ru/alekseev/mcp/models/MCPModels.kt",
            "content": "package ru.alekseev.mcp.models import kotlinx.serialization.Serializable import kotlinx.serialization.json.JsonElement import kotlinx.serialization.json.JsonObject // JSON-RPC Request/Response Models @Serializable data class JSONRPCRequest( val jsonrpc: String = \"2.0\", val id: Int? = null, val method: String, val params: JsonObject? = null ) @Serializable data class JSONRPCResponse( val jsonrpc: String = \"2.0\", val id: Int? = null, val result: JsonElement? = null, val error: JSONRPCError? = null ) @Serializable data class JSONRPCError( val code: Int, val message: String, val data: JsonElement? = null ) // MCP Protocol Models @Serializable data class ServerInfo( val name: String, val version: String ) @Serializable data class ServerCapabilities( val tools: JsonObject? = null ) @Serializable data class InitializeResult( val protocolVersion: String = \"2024-11-05\", val serverInfo: ServerInfo, val capabilities: ServerCapabilities ) @Serializable data class Tool( val name: String, val description: String, val inputSchema: JsonObject ) @Serializable data class ListToolsResult( val tools: List<Tool> ) @Serializable data class CallToolParams( val name: String, val arguments: JsonObject? = null ) @Serializable data class TextContent( val type: String = \"text\", val text: String ) @Serializable data class CallToolResult( val content: List<TextContent>, val isError: Boolean = false )",
            "startTokenIndex": 0,
            "endTokenIndex": 178,
            "fileType": "kt"
        },
        {
            "chunkId": "2223a954-4688-436e-a455-f3e4cf3edb53",
            "filePath": "mcp-server/src/main/kotlin/ru/alekseev/mcp/services/calendar/models/CalendarModels.kt",
            "content": "import kotlinx.serialization.Serializable @Serializable data class ListEventsParams( val maxResults: Int = 10, val timeMin: String? = null, val timeMax: String? = null, val calendarId: String = \"primary\", ) @Serializable data class CreateEventParams( val summary: String, val description: String? = null, val startDateTime: String, val endDateTime: String, val timeZone: String = \"UTC\", val attendees: List<String>? = null, val calendarId: String = \"primary\", ) @Serializable data class UpdateEventParams( val eventId: String, val summary: String? = null, val description: String? = null, val startDateTime: String? = null, val endDateTime: String? = null, val timeZone: String? = null, val calendarId: String = \"primary\", ) @Serializable data class DeleteEventParams( val eventId: String, val calendarId: String = \"primary\", )",
            "startTokenIndex": 0,
            "endTokenIndex": 112,
            "fileType": "kt"
        },
        {
            "chunkId": "7b079a86-e15b-4bc2-b0da-d22e9eb55fbf",
            "filePath": "mcp-server/src/main/kotlin/ru/alekseev/mcp/services/calendar/CalendarToolProvider.kt",
            "content": "package ru.alekseev.mcp.services.calendar import CreateEventParams import DeleteEventParams import ListEventsParams import UpdateEventParams import kotlinx.serialization.json.Json import kotlinx.serialization.json.JsonObject import kotlinx.serialization.json.add import kotlinx.serialization.json.buildJsonArray import kotlinx.serialization.json.buildJsonObject import kotlinx.serialization.json.decodeFromJsonElement import kotlinx.serialization.json.put import ru.alekseev.mcp.MCPToolProvider import ru.alekseev.mcp.models.Tool /** * Provides Google Calendar tools for MCP server */ class CalendarToolProvider( private val calendarService: GoogleCalendarService ) : MCPToolProvider { private val json = Json { ignoreUnknownKeys = true encodeDefaults = true } override fun getTools(): List<Tool> = listOf( Tool( name = \"list_events\", description = \"List upcoming events from Google Calendar. You can specify the number of events to retrieve (default: 10) and a time range.\", inputSchema = buildJsonObject { put(\"type\", \"object\") put(\"properties\", buildJsonObject { put(\"maxResults\", buildJsonObject { put(\"type\", \"number\") put(\"description\", \"Maximum number of events to return (default: 10)\") put(\"default\", 10) }) put(\"timeMin\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Start time for events (ISO 8601 format). Defaults to now.\") }) put(\"timeMax\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"End time for events (ISO 8601 format). Optional.\") }) put(\"calendarId\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Calendar ID to query (default: 'primary')\") put(\"default\", \"primary\") }) }) } ), Tool( name = \"create_event\", description = \"Create a new event in Google Calendar with specified details.\", inputSchema = buildJsonObject { put(\"type\", \"object\") put(\"properties\", buildJsonObject { put(\"summary\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Event title/summary\") }) put(\"description\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Event description (optional)\") }) put(\"startDateTime\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Start date-time in ISO 8601 format\") }) put(\"endDateTime\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"End date-time in ISO 8601 format\") }) put(\"timeZone\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Time zone (default: 'UTC')\") put(\"default\", \"UTC\") }) put(\"attendees\", buildJsonObject { put(\"type\", \"array\") put(\"description\", \"List of attendee email addresses (optional)\") put(\"items\", buildJsonObject { put(\"type\", \"string\") }) }) put(\"calendarId\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Calendar ID (default: 'primary')\") put(\"default\", \"primary\") }) }) put(\"required\", buildJsonArray { add(\"summary\") add(\"startDateTime\") add(\"endDateTime\") }) } ), Tool( name = \"update_event\", description = \"Update an existing event in Google Calendar.\", inputSchema = buildJsonObject { put(\"type\", \"object\") put(\"properties\", buildJsonObject { put(\"eventId\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"ID of the event to update\") }) put(\"summary\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"New event title/summary (optional)\") }) put(\"description\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"New event description (optional)\") }) put(\"startDateTime\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"New start date-time in ISO 8601 format (optional)\") }) put(\"endDateTime\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"New end date-time in ISO 8601 format (optional)\") }) put(\"timeZone\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Time zone (optional)\") }) put(\"calendarId\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Calendar ID (default: 'primary')\") put(\"default\", \"primary\") }) }) put(\"required\", buildJsonArray { add(\"eventId\") }) } ), Tool( name = \"delete_event\", description = \"Delete an event from Google Calendar.\", inputSchema = buildJsonObject { put(\"type\", \"object\") put(\"properties\", buildJsonObject { put(\"eventId\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"ID of the event to delete\") }) put(\"calendarId\", buildJsonObject { put(\"type\", \"string\") put(\"description\", \"Calendar ID (default: 'primary')\") put(\"default\", \"primary\") }) }) put(\"required\", buildJsonArray { add(\"eventId\") }) } ) ) override fun handleToolCall(toolName: String, arguments: JsonObject?): String { System.err.println(\"[CalendarToolProvider] Calling tool: $toolName\") System.err.println(\"[CalendarToolProvider] Tool arguments: $arguments\") return when (toolName) { \"list_events\" -> { val args = parseParams<ListEventsParams>(arguments) ?: ListEventsParams() System.err.println(\"[CalendarToolProvider] list_events: maxResults=${args.maxResults}, calendarId=${args.calendarId}\") calendarService.listEvents(args).also { System.err.println(\"[CalendarToolProvider] list_events completed successfully\") } } \"create_event\" -> { val args = parseParams<CreateEventParams>(arguments) ?: throw IllegalArgumentException(\"Missing required arguments\") System.err.println(\"[CalendarToolProvider] create_event: summary=${args.summary}, start=${args.startDateTime}, end=${args.endDateTime}\") calendarService.createEvent(args).also { System.err.println(\"[CalendarToolProvider] create_event completed successfully\") } } \"update_event\" -> { val args = parseParams<UpdateEventParams>(arguments) ?: throw IllegalArgumentException(\"Missing required arguments\") System.err.println(\"[CalendarToolProvider] update_event: eventId=${args.eventId}\") calendarService.updateEvent(args).also { System.err.println(\"[CalendarToolProvider] update_event completed successfully\") } } \"delete_event\" -> { val args = parseParams<DeleteEventParams>(arguments) ?: throw IllegalArgumentException(\"Missing required arguments\") System.err.println(\"[CalendarToolProvider] delete_event: eventId=${args.eventId}, calendarId=${args.calendarId}\") calendarService.deleteEvent(args).also { System.err.println(\"[CalendarToolProvider] delete_event completed successfully\") } } else -> throw IllegalArgumentException(\"Unknown tool: $toolName\") } } private inline fun <reified T> parseParams(args: JsonObject?): T? { return args?.let { json.decodeFromJsonElement<T>(it) } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 606,
            "fileType": "kt"
        },
        {
            "chunkId": "713c59c5-1f58-432a-80f9-d03c01f84730",
            "filePath": "mcp-server/src/main/kotlin/ru/alekseev/mcp/services/reminder/models/ReminderModels.kt",
            "content": "import kotlinx.serialization.Serializable @Serializable data class Reminder( val id: Long, val title: String, val description: String?, val priority: String, val completed: Boolean, val createdAt: Long, val dueDate: Long?, val tags: List<String>, ) @Serializable data class AddReminderParams( val title: String, val description: String? = null, val priority: String = \"medium\", val dueDate: Long? = null, val tags: List<String> = emptyList(), ) @Serializable data class UpdateReminderParams( val id: Long, val title: String? = null, val description: String? = null, val priority: String? = null, val completed: Boolean? = null, val dueDate: Long? = null, val tags: List<String>? = null, )",
            "startTokenIndex": 0,
            "endTokenIndex": 97,
            "fileType": "kt"
        },
        {
            "chunkId": "2866ad8c-b104-4503-9e32-43506a0d0d6b",
            "filePath": "mcp-server/src/main/kotlin/ru/alekseev/mcp/MCPServer.kt",
            "content": "package ru.alekseev.mcp import kotlinx.serialization.json.Json import kotlinx.serialization.json.buildJsonObject import kotlinx.serialization.json.decodeFromJsonElement import kotlinx.serialization.json.encodeToJsonElement import ru.alekseev.mcp.models.CallToolParams import ru.alekseev.mcp.models.CallToolResult import ru.alekseev.mcp.models.InitializeResult import ru.alekseev.mcp.models.JSONRPCError import ru.alekseev.mcp.models.JSONRPCRequest import ru.alekseev.mcp.models.JSONRPCResponse import ru.alekseev.mcp.models.ListToolsResult import ru.alekseev.mcp.models.ServerCapabilities import ru.alekseev.mcp.models.ServerInfo import ru.alekseev.mcp.models.TextContent /** * Main MCP Server class that handles JSONRPC protocol. * Delegates tool execution to registered tool providers. */ class MCPServer( private val toolProviders: List<MCPToolProvider> ) { private val json = Json { ignoreUnknownKeys = true encodeDefaults = true } fun handleRequest(request: JSONRPCRequest): JSONRPCResponse { System.err.println(\"[MCPServer] Handling request: method=${request.method}, id=${request.id}\") return try { val response = when (request.method) { \"initialize\" -> handleInitialize(request) \"tools/list\" -> handleListTools(request) \"tools/call\" -> handleCallTool(request) else -> { System.err.println(\"[MCPServer] ERROR: Method not found: ${request.method}\") JSONRPCResponse( id = request.id, error = JSONRPCError(-32601, \"Method not found: ${request.method}\") ) } } System.err.println(\"[MCPServer] Successfully handled request: method=${request.method}\") response } catch (e: Exception) { System.err.println(\"[MCPServer] ERROR: Internal error handling request: ${e.message}\") e.printStackTrace(System.err) JSONRPCResponse( id = request.id, error = JSONRPCError(-32603, \"Internal error: ${e.message}\") ) } } private fun handleInitialize(request: JSONRPCRequest): JSONRPCResponse { System.err.println(\"[MCPServer] Initializing server...\") val result = InitializeResult( serverInfo = ServerInfo( name = \"google-calendar-mcp\", version = \"1.0.0\" ), capabilities = ServerCapabilities( tools = buildJsonObject { } ) ) System.err.println(\"[MCPServer] Server initialized: name=google-calendar-mcp, version=1.0.0\") return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement(result) ) } private fun handleListTools(request: JSONRPCRequest): JSONRPCResponse { System.err.println(\"[MCPServer] Listing available tools...\") // Collect all tools from all providers val tools = toolProviders.flatMap { it.getTools() } System.err.println(\"[MCPServer] Found ${tools.size} tools: ${tools.map { it.name }}\") val result = ListToolsResult(tools) return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement(result) ) } private fun handleCallTool(request: JSONRPCRequest): JSONRPCResponse { val params = request.params?.let { json.decodeFromJsonElement<CallToolParams>(it) } ?: run { System.err.println(\"[MCPServer] ERROR: Invalid params in tool call\") return JSONRPCResponse( id = request.id, error = JSONRPCError(-32602, \"Invalid params\") ) } System.err.println(\"[MCPServer] Calling tool: ${params.name}\") System.err.println(\"[MCPServer] Tool arguments: ${params.arguments}\") val resultText = try { // Find the provider that supports this tool val provider = toolProviders.firstOrNull { it.supportsTool(params.name) } ?: throw IllegalArgumentException(\"Unknown tool: ${params.name}\") // Delegate to the provider provider.handleToolCall(params.name, params.arguments) } catch (e: Exception) { System.err.println(\"[MCPServer] ERROR: Tool call failed: ${e.message}\") e.printStackTrace(System.err) return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement( CallToolResult( content = listOf(TextContent(text = \"Error: ${e.message}\")), isError = true ) ) ) } val result = CallToolResult( content = listOf(TextContent(text = resultText)) ) return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement(result) ) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 377,
            "fileType": "kt"
        },
        {
            "chunkId": "1b4e3541-abc4-48a9-9565-73748823dc5e",
            "filePath": "mcp-server/src/main/kotlin/ru/alekseev/mcp/MCPToolProvider.kt",
            "content": "package ru.alekseev.mcp import kotlinx.serialization.json.JsonObject import ru.alekseev.mcp.models.Tool /** * Interface for MCP tool providers. * Each service (Calendar, Reminder, etc.) should implement this interface * to provide its tools and handle their execution. */ interface MCPToolProvider { /** * Returns the list of tools provided by this provider */ fun getTools(): List<Tool> /** * Handles the execution of a tool * @param toolName - name of the tool to execute * @param arguments - arguments for the tool * @return result text from the tool execution * @throws IllegalArgumentException if tool is not supported or arguments are invalid */ fun handleToolCall(toolName: String, arguments: JsonObject?): String /** * Checks if this provider supports the given tool */ fun supportsTool(toolName: String): Boolean { return getTools().any { it.name == toolName } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 129,
            "fileType": "kt"
        },
        {
            "chunkId": "e923efcc-4225-4a9e-a254-fe83cdb5f6b7",
            "filePath": "mcp-server/src/main/kotlin/ru/alekseev/mcp/Main.kt",
            "content": "package ru.alekseev.mcp import kotlinx.serialization.json.Json import ru.alekseev.mcp.models.JSONRPCError import ru.alekseev.mcp.models.JSONRPCRequest import ru.alekseev.mcp.models.JSONRPCResponse import ru.alekseev.mcp.services.calendar.CalendarToolProvider import ru.alekseev.mcp.services.calendar.GoogleCalendarService import ru.alekseev.mcp.services.reminder.ReminderService import ru.alekseev.mcp.services.reminder.ReminderToolProvider import java.io.BufferedReader import java.io.InputStreamReader fun main() { System.err.println(\"MCP Server starting (Google Calendar + Reminders)...\") // Create services val calendarService = GoogleCalendarService() val reminderService = ReminderService() // Create tool providers val toolProviders = listOf( CalendarToolProvider(calendarService), ReminderToolProvider(reminderService) ) // Create MCP server with all providers val server = MCPServer(toolProviders) val json = Json { ignoreUnknownKeys = true encodeDefaults = true } val reader = BufferedReader(InputStreamReader(System.`in`)) System.err.println(\"MCP Server running on stdio with Calendar and Reminder tools\") try { while (true) { val line = reader.readLine() ?: break if (line.isBlank()) continue System.err.println(\"Received request: $line\") try { val request = json.decodeFromString<JSONRPCRequest>(line) val response = server.handleRequest(request) val responseJson = json.encodeToString(JSONRPCResponse.serializer(), response) println(responseJson) System.out.flush() System.err.println(\"Sent response: $responseJson\") } catch (e: Exception) { System.err.println(\"Error processing request: ${e.message}\") e.printStackTrace(System.err) val errorResponse = JSONRPCResponse( error = JSONRPCError(-32700, \"Parse error: ${e.message}\") ) val errorJson = json.encodeToString(JSONRPCResponse.serializer(), errorResponse) println(errorJson) System.out.flush() } } } catch (e: Exception) { System.err.println(\"Fatal error: ${e.message}\") e.printStackTrace(System.err) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 169,
            "fileType": "kt"
        },
        {
            "chunkId": "8de9d74f-401a-4b40-8c3a-debf1830e899",
            "filePath": "mcp-server/README.md",
            "content": "Error: Cannot read binary file: README.md",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "md"
        },
        {
            "chunkId": "85069a0d-5242-49f5-8df6-a2f1d710cbdf",
            "filePath": "mcp-server/build.gradle.kts",
            "content": "plugins { alias(libs.plugins.kotlinJvm) alias(libs.plugins.kotlinSerialization) application } group = \"ru.alekseev.mcp\" version = \"1.0.0\" application { mainClass.set(\"ru.alekseev.mcp.MainKt\") } dependencies { // Serialization implementation(libs.serialization.json) // Coroutines implementation(libs.kotlinx.coroutines) // Google API Client implementation(libs.google.api.client) implementation(libs.google.oauth.client) implementation(libs.google.api.calendar) // Ktor Client for HTTP implementation(libs.ktor.client.core) implementation(libs.ktor.client.cio) // SQLite for Reminders implementation(libs.sqlite.jdbc) // Logging implementation(libs.logback) } tasks.withType<Jar> { manifest { attributes[\"Main-Class\"] = \"ru.alekseev.mcp.MainKt\" } // Create fat JAR duplicatesStrategy = DuplicatesStrategy.EXCLUDE from(configurations.runtimeClasspath.get().map { if (it.isDirectory) it else zipTree(it) }) }",
            "startTokenIndex": 0,
            "endTokenIndex": 71,
            "fileType": "kts"
        },
        {
            "chunkId": "c565cd38-75f0-4cb9-a029-d6c50255dd6b",
            "filePath": "mcp-server-devops/src/main/kotlin/ru/alekseev/mcp/devops/models/MCPModels.kt",
            "content": "package ru.alekseev.mcp.devops.models import kotlinx.serialization.Serializable import kotlinx.serialization.json.JsonElement import kotlinx.serialization.json.JsonObject // JSON-RPC Request/Response Models @Serializable data class JSONRPCRequest( val jsonrpc: String = \"2.0\", val id: Int? = null, val method: String, val params: JsonObject? = null ) @Serializable data class JSONRPCResponse( val jsonrpc: String = \"2.0\", val id: Int? = null, val result: JsonElement? = null, val error: JSONRPCError? = null ) @Serializable data class JSONRPCError( val code: Int, val message: String, val data: JsonElement? = null ) // MCP Protocol Models @Serializable data class ServerInfo( val name: String, val version: String ) @Serializable data class ServerCapabilities( val tools: JsonObject? = null ) @Serializable data class InitializeResult( val protocolVersion: String = \"2024-11-05\", val serverInfo: ServerInfo, val capabilities: ServerCapabilities ) @Serializable data class Tool( val name: String, val description: String, val inputSchema: JsonObject ) @Serializable data class ListToolsResult( val tools: List<Tool> ) @Serializable data class CallToolParams( val name: String, val arguments: JsonObject? = null ) @Serializable data class TextContent( val type: String = \"text\", val text: String ) @Serializable data class CallToolResult( val content: List<TextContent>, val isError: Boolean = false )",
            "startTokenIndex": 0,
            "endTokenIndex": 178,
            "fileType": "kt"
        },
        {
            "chunkId": "c52f583d-6e3d-4fe0-923a-ac9d3dbd12f9",
            "filePath": "mcp-server-devops/src/main/kotlin/ru/alekseev/mcp/devops/DevOpsToolProvider.kt",
            "content": "package ru.alekseev.mcp.devops import kotlinx.serialization.json.* import ru.alekseev.mcp.devops.models.Tool import java.io.File /** * MCP Tool Provider for DevOps operations: * - Docker container management * - Android app building * - Emulator deployment */ class DevOpsToolProvider( private val projectRoot: String = System.getProperty(\"user.dir\") ) : MCPToolProvider { override fun getTools(): List<Tool> = listOf( Tool( name = \"docker_ps\", description = \"List all running Docker containers with their status, names, and ports\", inputSchema = buildJsonObject { put(\"type\", \"object\") putJsonObject(\"properties\") { } putJsonArray(\"required\") { } } ), Tool( name = \"build_android_app\", description = \"Build the Android application using Gradle assembleDebug task. Returns the path to the generated APK file.\", inputSchema = buildJsonObject { put(\"type\", \"object\") putJsonObject(\"properties\") { putJsonObject(\"clean\") { put(\"type\", \"boolean\") put(\"description\", \"Whether to run clean before build (default: false)\") } } putJsonArray(\"required\") { } } ), Tool( name = \"deploy_to_emulator\", description = \"Install and launch the Android app on a running emulator. Requires an APK file path and checks that an emulator is running.\", inputSchema = buildJsonObject { put(\"type\", \"object\") putJsonObject(\"properties\") { putJsonObject(\"apk_path\") { put(\"type\", \"string\") put(\"description\", \"Path to the APK file to install\") } putJsonObject(\"package_name\") { put(\"type\", \"string\") put(\"description\", \"Package name to launch (default: ru.alekseev.myapplication)\") } } putJsonArray(\"required\") { add(\"apk_path\") } } ) ) override fun handleToolCall(toolName: String, arguments: JsonObject?): String { return when (toolName) { \"docker_ps\" -> handleDockerPs() \"build_android_app\" -> handleBuildAndroidApp(arguments) \"deploy_to_emulator\" -> handleDeployToEmulator(arguments) else -> throw IllegalArgumentException(\"Unknown tool: $toolName\") } } private fun handleDockerPs(): String { val result = executeCommand( listOf(\"docker\", \"ps\", \"--format\", \"table {{.ID}}\\\\t{{.Names}}\\\\t{{.Status}}\\\\t{{.Ports}}\"), workingDir = File(projectRoot) ) return if (result.exitCode == 0) { \"Docker Containers:\\n${result.output}\" } else { throw Exception(\"Failed to list Docker containers: ${result.error}\") } } private fun handleBuildAndroidApp(arguments: JsonObject?): String { val clean = arguments?.get(\"clean\")?.jsonPrimitive?.content?.toBoolean() ?: false val tasks = mutableListOf<String>() if (clean) { tasks.add(\"clean\") } tasks.add(\":composeApp:assembleDebug\") val command = mutableListOf(\"./gradlew\") command.addAll(tasks) System.err.println(\"[DevOpsToolProvider] Running: ${command.joinToString(\" \")}\") val result = executeCommand( command, workingDir = File(projectRoot), timeout = 300_000 // 5 minutes for build ) if (result.exitCode != 0) { throw Exception(\"Build failed with exit code ${result.exitCode}:\\n${result.error}\") } // Find the generated APK val apkPath = File(projectRoot, \"composeApp/build/outputs/apk/debug\").let { dir -> dir.listFiles()?.firstOrNull { it.extension == \"apk\" }?.absolutePath } return if (apkPath != null) { \"Build successful!\\nAPK location: $apkPath\\n\\nBuild output:\\n${result.output.takeLast(500)}\" } else { \"Build completed but APK not found at expected location.\\n\\nBuild output:\\n${result.output.takeLast(500)}\" } } private fun handleDeployToEmulator(arguments: JsonObject?): String { val apkPath = arguments?.get(\"apk_path\")?.jsonPrimitive?.content ?: throw IllegalArgumentException(\"apk_path is required\") val packageName = arguments[\"package_name\"]?.jsonPrimitive?.content ?: \"ru.alekseev.myapplication\" val apkFile = File(apkPath) if (!apkFile.exists()) { throw IllegalArgumentException(\"APK file not found: $apkPath\") } // Check if emulator is running val devicesResult = executeCommand(listOf(\"adb\", \"devices\"), File(projectRoot)) if (devicesResult.exitCode != 0) { throw Exception(\"Failed to check for running emulators: ${devicesResult.error}\") } val runningDevices = devicesResult.output.lines() .drop(1) // Skip \"List of devices attached\" .filter { it.contains(\"device\") && !it.contains(\"offline\") } if (runningDevices.isEmpty()) { throw Exception(\"No running emulator found. Please start an Android emulator first.\\n\\nADB output:\\n${devicesResult.output}\") } System.err.println(\"[DevOpsToolProvider] Found ${runningDevices.size} device(s)\") // Install APK val installResult = executeCommand( listOf(\"adb\", \"install\", \"-r\", apkFile.absolutePath), workingDir = File(projectRoot), timeout = 60_000 // 1 minute for install ) if (installResult.exitCode != 0) { throw Exception(\"Failed to install APK: ${installResult.error}\") } // Launch the app val launchResult = executeCommand( listOf(\"adb\", \"shell\", \"am\", \"start\", \"-n\", \"$packageName/.MainActivity\"), workingDir = File(projectRoot) ) if (launchResult.exitCode != 0) { return \"APK installed successfully, but failed to launch app: ${launchResult.error}\\n\\nYou may need to manually launch the app or adjust the package/activity name.\" } return \"Successfully deployed to emulator!\\n\\nInstall output:\\n${installResult.output}\\n\\nLaunch output:\\n${launchResult.output}\" } /** * Execute a shell command and return the result */ private fun executeCommand( command: List<String>, workingDir: File, timeout: Long = 30_000 ): CommandResult { val processBuilder = ProcessBuilder(command) .directory(workingDir) .redirectErrorStream(false) val process = processBuilder.start() val output = process.inputStream.bufferedReader().readText() val error = process.errorStream.bufferedReader().readText() val completed = process.waitFor(timeout, java.util.concurrent.TimeUnit.MILLISECONDS) if (!completed) { process.destroyForcibly() throw Exception(\"Command timed out after ${timeout}ms: ${command.joinToString(\" \")}\") } return CommandResult( exitCode = process.exitValue(), output = output, error = error ) } private data class CommandResult( val exitCode: Int, val output: String, val error: String ) }",
            "startTokenIndex": 0,
            "endTokenIndex": 649,
            "fileType": "kt"
        },
        {
            "chunkId": "91d9dd9a-219d-471d-890b-f575d86fed30",
            "filePath": "mcp-server-devops/src/main/kotlin/ru/alekseev/mcp/devops/FilesystemToolProvider.kt",
            "content": "package ru.alekseev.mcp.devops import kotlinx.serialization.json.* import ru.alekseev.mcp.devops.models.Tool import java.io.File import java.nio.file.Files /** * MCP Tool Provider for read-only filesystem operations. * Provides tools for listing directories and reading files. */ class FilesystemToolProvider( private val projectRoot: String = System.getProperty(\"user.dir\") ) : MCPToolProvider { override fun getTools(): List<Tool> = listOf( Tool( name = \"list_directory\", description = \"List all files and directories in the specified path. Returns file names, types (file/directory), and sizes.\", inputSchema = buildJsonObject { put(\"type\", \"object\") putJsonObject(\"properties\") { putJsonObject(\"path\") { put(\"type\", \"string\") put(\"description\", \"Relative or absolute path to list. If relative, resolved from project root.\") } putJsonObject(\"recursive\") { put(\"type\", \"boolean\") put(\"description\", \"Whether to list recursively (default: false)\") } } putJsonArray(\"required\") { add(\"path\") } } ), Tool( name = \"read_file\", description = \"Read the contents of a text file. Returns the file content as a string.\", inputSchema = buildJsonObject { put(\"type\", \"object\") putJsonObject(\"properties\") { putJsonObject(\"path\") { put(\"type\", \"string\") put(\"description\", \"Relative or absolute path to the file. If relative, resolved from project root.\") } } putJsonArray(\"required\") { add(\"path\") } } ) ) override fun handleToolCall(toolName: String, arguments: JsonObject?): String { return when (toolName) { \"list_directory\" -> handleListDirectory(arguments) \"read_file\" -> handleReadFile(arguments) else -> throw IllegalArgumentException(\"Unknown tool: $toolName\") } } private fun handleListDirectory(arguments: JsonObject?): String { val pathArg = arguments?.get(\"path\")?.jsonPrimitive?.content ?: throw IllegalArgumentException(\"path is required\") val recursive = arguments[\"recursive\"]?.jsonPrimitive?.booleanOrNull ?: false val targetPath = resolvePathSafely(pathArg) if (!targetPath.exists()) { throw IllegalArgumentException(\"Path does not exist: ${targetPath.absolutePath}\") } if (!targetPath.isDirectory) { throw IllegalArgumentException(\"Path is not a directory: ${targetPath.absolutePath}\") } return if (recursive) { buildRecursiveDirectoryListing(targetPath) } else { buildDirectoryListing(targetPath) } } private fun buildDirectoryListing(dir: File): String { val files = dir.listFiles()?.sortedWith(compareBy({ !it.isDirectory }, { it.name })) ?: return \"Directory is empty or cannot be read\" val result = StringBuilder() result.appendLine(\"Directory: ${dir.absolutePath}\") result.appendLine(\"Total items: ${files.size}\") result.appendLine() files.forEach { file -> val type = if (file.isDirectory) \"DIR \" else \"FILE\" val size = if (file.isFile) formatFileSize(file.length()) else \"-\" result.appendLine(\"$type ${file.name.padEnd(50)} $size\") } return result.toString() } private fun buildRecursiveDirectoryListing(dir: File): String { val result = StringBuilder() result.appendLine(\"Recursive listing of: ${dir.absolutePath}\") result.appendLine() walkDirectory(dir, \"\", result) return result.toString() } private fun walkDirectory(dir: File, indent: String, result: StringBuilder) { val files = dir.listFiles()?.sortedWith(compareBy({ !it.isDirectory }, { it.name })) ?: return files.forEach { file -> val type = if (file.isDirectory) \"DIR \" else \"FILE\" val size = if (file.isFile) formatFileSize(file.length()) else \"\" result.appendLine(\"$indent$type ${file.name} $size\") if (file.isDirectory) { walkDirectory(file, \"$indent \", result) } } } private fun handleReadFile(arguments: JsonObject?): String { val pathArg = arguments?.get(\"path\")?.jsonPrimitive?.content ?: throw IllegalArgumentException(\"path is required\") val targetFile = resolvePathSafely(pathArg) if (!targetFile.exists()) { throw IllegalArgumentException(\"File does not exist: ${targetFile.absolutePath}\") } if (!targetFile.isFile) { throw IllegalArgumentException(\"Path is not a file: ${targetFile.absolutePath}\") } // Check if file is binary if (isBinaryFile(targetFile)) { throw IllegalArgumentException(\"Cannot read binary file: ${targetFile.name}\") } // Read file content return try { targetFile.readText(Charsets.UTF_8) } catch (e: Exception) { throw IllegalArgumentException(\"Failed to read file: ${e.message}\") } } /** * Resolve path safely, preventing directory traversal attacks */ private fun resolvePathSafely(pathArg: String): File { val baseDir = File(projectRoot).canonicalFile val targetFile = File(baseDir, pathArg).canonicalFile // Ensure the target is within the project root if (!targetFile.canonicalPath.startsWith(baseDir.canonicalPath)) { throw IllegalArgumentException(\"Access denied: path outside project root\") } return targetFile } /** * Check if a file is binary by examining the first 512 bytes */ private fun isBinaryFile(file: File): Boolean { if (file.length() == 0L) return false val sampleSize = minOf(512, file.length().toInt()) val bytes = file.inputStream().use { it.readNBytes(sampleSize) } // Check for null bytes or high ratio of non-printable characters var nonPrintable = 0 bytes.forEach { byte -> if (byte.toInt() == 0) return true // Null byte = binary if (byte < 0x20 && byte != 0x09.toByte() && byte != 0x0A.toByte() && byte != 0x0D.toByte()) { nonPrintable++ } } return nonPrintable.toDouble() / bytes.size > 0.3 } private fun formatFileSize(bytes: Long): String { return when { bytes < 1024 -> \"$bytes B\" bytes < 1024 * 1024 -> \"${bytes / 1024} KB\" else -> \"${bytes / (1024 * 1024)} MB\" } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 646,
            "fileType": "kt"
        },
        {
            "chunkId": "caf4c81c-0128-49dd-8c40-da2d48032a15",
            "filePath": "mcp-server-devops/src/main/kotlin/ru/alekseev/mcp/devops/MCPHttpServer.kt",
            "content": "package ru.alekseev.mcp.devops import io.ktor.serialization.kotlinx.json.* import io.ktor.server.application.* import io.ktor.server.engine.* import io.ktor.server.netty.* import io.ktor.server.plugins.contentnegotiation.* import io.ktor.server.request.* import io.ktor.server.response.* import io.ktor.server.routing.* import kotlinx.serialization.json.Json import ru.alekseev.mcp.devops.models.JSONRPCRequest import ru.alekseev.mcp.devops.models.JSONRPCResponse import ru.alekseev.mcp.devops.models.JSONRPCError /** * HTTP server wrapper for MCP Server. * Provides HTTP POST endpoint for MCP JSON-RPC requests. */ class MCPHttpServer( private val mcpServer: MCPServer, private val port: Int = 8082 ) { private val json = Json { ignoreUnknownKeys = true encodeDefaults = true } fun start() { embeddedServer(Netty, port = port) { install(ContentNegotiation) { json(json) } routing { // Health check endpoint get(\"/health\") { call.respondText(\"OK\") } // MCP JSON-RPC endpoint post(\"/mcp\") { try { val request = call.receive<JSONRPCRequest>() System.err.println(\"[MCPHttpServer] Received request: method=${request.method}, id=${request.id}\") val response = mcpServer.handleRequest(request) call.respond(response) } catch (e: Exception) { System.err.println(\"[MCPHttpServer] Error handling request: ${e.message}\") e.printStackTrace(System.err) call.respond( JSONRPCResponse( error = JSONRPCError( code = -32603, message = \"Internal error: ${e.message}\" ) ) ) } } } }.start(wait = true) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 150,
            "fileType": "kt"
        },
        {
            "chunkId": "8de3cfce-a4b2-4370-8ed7-131462d5e794",
            "filePath": "mcp-server-devops/src/main/kotlin/ru/alekseev/mcp/devops/MCPServer.kt",
            "content": "package ru.alekseev.mcp.devops import kotlinx.serialization.json.Json import kotlinx.serialization.json.buildJsonObject import kotlinx.serialization.json.decodeFromJsonElement import kotlinx.serialization.json.encodeToJsonElement import ru.alekseev.mcp.devops.models.* /** * Main MCP Server class that handles JSONRPC protocol. * Delegates tool execution to registered tool providers. */ class MCPServer( private val toolProviders: List<MCPToolProvider> ) { private val json = Json { ignoreUnknownKeys = true encodeDefaults = true } fun handleRequest(request: JSONRPCRequest): JSONRPCResponse { System.err.println(\"[MCPServer] Handling request: method=${request.method}, id=${request.id}\") return try { val response = when (request.method) { \"initialize\" -> handleInitialize(request) \"tools/list\" -> handleListTools(request) \"tools/call\" -> handleCallTool(request) else -> { System.err.println(\"[MCPServer] ERROR: Method not found: ${request.method}\") JSONRPCResponse( id = request.id, error = JSONRPCError(-32601, \"Method not found: ${request.method}\") ) } } System.err.println(\"[MCPServer] Successfully handled request: method=${request.method}\") response } catch (e: Exception) { System.err.println(\"[MCPServer] ERROR: Internal error handling request: ${e.message}\") e.printStackTrace(System.err) JSONRPCResponse( id = request.id, error = JSONRPCError(-32603, \"Internal error: ${e.message}\") ) } } private fun handleInitialize(request: JSONRPCRequest): JSONRPCResponse { System.err.println(\"[MCPServer] Initializing server...\") val result = InitializeResult( serverInfo = ServerInfo( name = \"devops-mcp\", version = \"1.0.0\" ), capabilities = ServerCapabilities( tools = buildJsonObject { } ) ) System.err.println(\"[MCPServer] Server initialized: name=devops-mcp, version=1.0.0\") return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement(result) ) } private fun handleListTools(request: JSONRPCRequest): JSONRPCResponse { System.err.println(\"[MCPServer] Listing available tools...\") // Collect all tools from all providers val tools = toolProviders.flatMap { it.getTools() } System.err.println(\"[MCPServer] Found ${tools.size} tools: ${tools.map { it.name }}\") val result = ListToolsResult(tools) return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement(result) ) } private fun handleCallTool(request: JSONRPCRequest): JSONRPCResponse { val params = request.params?.let { json.decodeFromJsonElement<CallToolParams>(it) } ?: run { System.err.println(\"[MCPServer] ERROR: Invalid params in tool call\") return JSONRPCResponse( id = request.id, error = JSONRPCError(-32602, \"Invalid params\") ) } System.err.println(\"[MCPServer] Calling tool: ${params.name}\") System.err.println(\"[MCPServer] Tool arguments: ${params.arguments}\") val resultText = try { // Find the provider that supports this tool val provider = toolProviders.firstOrNull { it.supportsTool(params.name) } ?: throw IllegalArgumentException(\"Unknown tool: ${params.name}\") // Delegate to the provider provider.handleToolCall(params.name, params.arguments) } catch (e: Exception) { System.err.println(\"[MCPServer] ERROR: Tool call failed: ${e.message}\") e.printStackTrace(System.err) return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement( CallToolResult( content = listOf(TextContent(text = \"Error: ${e.message}\")), isError = true ) ) ) } val result = CallToolResult( content = listOf(TextContent(text = resultText)) ) return JSONRPCResponse( id = request.id, result = json.encodeToJsonElement(result) ) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 359,
            "fileType": "kt"
        },
        {
            "chunkId": "5cced75d-2199-4cd1-859e-52597430037f",
            "filePath": "mcp-server-devops/src/main/kotlin/ru/alekseev/mcp/devops/MCPToolProvider.kt",
            "content": "package ru.alekseev.mcp.devops import kotlinx.serialization.json.JsonObject import ru.alekseev.mcp.devops.models.Tool /** * Interface for MCP tool providers. */ interface MCPToolProvider { /** * Returns the list of tools provided by this provider */ fun getTools(): List<Tool> /** * Handles the execution of a tool * @param toolName - name of the tool to execute * @param arguments - arguments for the tool * @return result text from the tool execution * @throws IllegalArgumentException if tool is not supported or arguments are invalid */ fun handleToolCall(toolName: String, arguments: JsonObject?): String /** * Checks if this provider supports the given tool */ fun supportsTool(toolName: String): Boolean { return getTools().any { it.name == toolName } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 110,
            "fileType": "kt"
        },
        {
            "chunkId": "07c47302-4bae-4ee9-9c16-5c59bf3733bd",
            "filePath": "mcp-server-devops/src/main/kotlin/ru/alekseev/mcp/devops/Main.kt",
            "content": "package ru.alekseev.mcp.devops fun main(args: Array<String>) { val port = args.firstOrNull()?.toIntOrNull() ?: 8082 System.err.println(\"DevOps MCP Server starting on port $port...\") val toolProviders = listOf( DevOpsToolProvider(), FilesystemToolProvider() ) val server = MCPServer(toolProviders) val httpServer = MCPHttpServer(server, port) System.err.println(\"DevOps MCP Server running on http://localhost:$port/mcp\") System.err.println(\"Available tools: docker_ps, build_android_app, deploy_to_emulator, list_directory, read_file\") System.err.println(\"Health check: http://localhost:$port/health\") httpServer.start() }",
            "startTokenIndex": 0,
            "endTokenIndex": 53,
            "fileType": "kt"
        },
        {
            "chunkId": "36a97f3e-cb6f-40cd-bdb8-5fc1ded940fd",
            "filePath": "mcp-server-devops/build.gradle.kts",
            "content": "plugins { alias(libs.plugins.kotlinJvm) alias(libs.plugins.kotlinSerialization) application } group = \"ru.alekseev.mcp\" version = \"1.0.0\" application { mainClass.set(\"ru.alekseev.mcp.devops.MainKt\") } dependencies { // Serialization implementation(libs.serialization.json) // Coroutines implementation(libs.kotlinx.coroutines) // Ktor Server for HTTP mode implementation(libs.ktor.serverCore) implementation(libs.ktor.serverNetty) implementation(libs.ktor.server.contentNegotiation) implementation(libs.ktor.serialization.json) // Logging implementation(libs.logback) } tasks.withType<Jar> { manifest { attributes[\"Main-Class\"] = \"ru.alekseev.mcp.devops.MainKt\" } // Create fat JAR duplicatesStrategy = DuplicatesStrategy.EXCLUDE from(configurations.runtimeClasspath.get().map { if (it.isDirectory) it else zipTree(it) }) }",
            "startTokenIndex": 0,
            "endTokenIndex": 62,
            "fileType": "kts"
        },
        {
            "chunkId": "1fbb4829-312d-434a-9f09-7cf98c0249c5",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/di/AppModule.kt",
            "content": "package ru.alekseev.myapplication.di import app.cash.sqldelight.db.SqlDriver import app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver import org.koin.dsl.module import ru.alekseev.myapplication.core.common.JsonFactory import ru.alekseev.myapplication.db.ChatDatabase import ru.alekseev.myapplication.repository.ChatRepository import ru.alekseev.myapplication.repository.ChatRepositoryImpl import ru.alekseev.myapplication.service.ClaudeApiService import ru.alekseev.myapplication.service.DocumentRAGService import ru.alekseev.myapplication.service.MCPClient import ru.alekseev.myapplication.service.MCPManager import ru.alekseev.myapplication.service.SummarizationService import ru.alekseev.myapplication.service.ReminderSchedulerService import ru.alekseev.myapplication.service.WebSocketManager import ru.alekseev.myapplication.usecase.HandleSummarizationUseCase import ru.alekseev.myapplication.usecase.LoadChatHistoryUseCase import ru.alekseev.myapplication.usecase.ProcessUserMessageUseCase import java.io.File import java.util.Properties val jsonModule = module { single { JsonFactory.create() } } val databaseModule = module { single<SqlDriver> { // Use system temp directory or user home for database file val dbPath = System.getProperty(\"user.home\") + \"/chat.db\" val driver = JdbcSqliteDriver( url = \"jdbc:sqlite:$dbPath\", properties = Properties().apply { put(\"foreign_keys\", \"true\") } ) // Create tables if they don't exist try { ChatDatabase.Schema.create(driver) } catch (e: Exception) { } driver } single { ChatDatabase(driver = get()) } } val serviceModule = module { single { ClaudeApiService(get(), get()) } single { SummarizationService(get()) } single { ReminderSchedulerService(get()) } single { WebSocketManager(get(), get()) } single { DocumentRAGService() } single { val mcpManager = MCPManager() // Configure Google Calendar MCP Server val projectRoot = System.getProperty(\"user.dir\") println(\"Current working directory: $projectRoot\") // Try multiple possible locations for credentials val possibleCredentialsPaths = listOf( \"$projectRoot/server/google-calendar-credentials.json\", \"${System.getProperty(\"user.home\")}/google-calendar-credentials.json\", \"./server/google-calendar-credentials.json\", \"./google-calendar-credentials.json\" ) val credentialsPath = possibleCredentialsPaths.firstOrNull { File(it).exists() } val tokensPath = \"$projectRoot/server/tokens\" if (credentialsPath != null) { println(\"Found Google Calendar credentials at: $credentialsPath\") // Try multiple possible locations for MCP server JAR val possibleJarPaths = listOf( \"$projectRoot/mcp-server/build/libs/mcp-server-1.0.0.jar\", \"./mcp-server/build/libs/mcp-server-1.0.0.jar\", \"../mcp-server/build/libs/mcp-server-1.0.0.jar\" ) val mcpServerJar = possibleJarPaths.firstOrNull { File(it).exists() } if (mcpServerJar != null) { println(\"Found MCP server JAR at: $mcpServerJar\") // Register Google Calendar MCP client val calendarClient = MCPClient( name = \"google-calendar\", command = listOf( \"java\", \"-jar\", File(mcpServerJar).absolutePath ), environment = mapOf( \"GOOGLE_CALENDAR_CREDENTIALS_PATH\" to File(credentialsPath).absolutePath, \"GOOGLE_CALENDAR_TOKENS_PATH\" to File(tokensPath).absolutePath ), workingDirectory = projectRoot ) mcpManager.registerClient(\"google-calendar\", calendarClient) println(\"Registered Google Calendar MCP client\") } else { println(\"WARNING: MCP server JAR not found. Tried:\") possibleJarPaths.forEach { println(\" - $it\") } println(\"Please build mcp-server: ./gradlew :mcp-server:jar\") } } else { println(\"WARNING: Google Calendar credentials not found. Tried:\") possibleCredentialsPaths.forEach { println(\" - $it\") } println(\"MCP Calendar tools will not be available\") println(\"Please place google-calendar-credentials.json in one of the above locations\") } // Configure GitHub MCP Server (Docker-based) val githubToken = System.getenv(\"GITHUB_PERSONAL_ACCESS_TOKEN\") if (githubToken != null && githubToken.isNotEmpty()) { println(\"Found GitHub token, registering GitHub MCP client\") val githubClient = MCPClient( name = \"github\", command = listOf( \"docker\", \"run\", \"-i\", \"--rm\", \"-e\", \"GITHUB_PERSONAL_ACCESS_TOKEN=$githubToken\", \"ghcr.io/github/github-mcp-server\" ), environment = mapOf(), workingDirectory = projectRoot ) mcpManager.registerClient(\"github\", githubClient) println(\"Registered GitHub MCP client\") } else { println(\"WARNING: GITHUB_PERSONAL_ACCESS_TOKEN not found in environment\") println(\"GitHub MCP tools will not be available\") println(\"Please set GITHUB_PERSONAL_ACCESS_TOKEN environment variable\") } // Configure DevOps MCP Server (HTTP-based, running on host) // This connects to the DevOps MCP server running on the host machine (Mac) // The server should be started with: ./start-devops-mcp.sh (or ./start-devops-mcp-background.sh) val devopsServerUrl = \"http://host.docker.internal:8082\" println(\"Registering DevOps MCP HTTP client at $devopsServerUrl\") val devopsClient = ru.alekseev.myapplication.service.MCPHttpClient( name = \"devops\", baseUrl = devopsServerUrl ) mcpManager.registerHttpClient(\"devops\", devopsClient) println(\"Registered DevOps MCP HTTP client (will connect when server starts)\") println(\"To start DevOps MCP server on host: ./start-devops-mcp.sh (foreground) or ./start-devops-mcp-background.sh (daemon)\") mcpManager } } val repositoryModule = module { single<ChatRepository> { ChatRepositoryImpl(get()) } } val useCaseModule = module { factory { LoadChatHistoryUseCase(get(), get()) } factory { HandleSummarizationUseCase(get(), get()) } factory { ProcessUserMessageUseCase(get(), get(), get(), get()) } } val appModules = listOf(jsonModule, databaseModule, serviceModule, repositoryModule, useCaseModule)",
            "startTokenIndex": 0,
            "endTokenIndex": 530,
            "fileType": "kt"
        },
        {
            "chunkId": "7dbeb274-fa41-407c-8837-d0d649d25133",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/mapper/MessageMapper.kt",
            "content": "package ru.alekseev.myapplication.mapper import kotlinx.serialization.json.Json import ru.alekseev.myapplication.core.common.ChatConstants import ru.alekseev.myapplication.core.common.ClaudeModels import ru.alekseev.myapplication.core.common.ClaudePricing import ru.alekseev.myapplication.data.dto.ChatMessageDto import ru.alekseev.myapplication.data.dto.ClaudeResponse import ru.alekseev.myapplication.data.dto.MessageInfoDto import ru.alekseev.myapplication.data.dto.MessageSender import ru.alekseev.myapplication.db.Message /** * Converts a database Message to a user ChatMessageDto. * The user message is sent before the assistant message, so it gets a slightly earlier timestamp. */ fun Message.toUserMessageDto(): ChatMessageDto { return ChatMessageDto( id = \"${this.id}${ChatConstants.USER_MESSAGE_ID_SUFFIX}\", content = this.user_message, sender = MessageSender.USER, timestamp = this.timestamp - ChatConstants.USER_MESSAGE_TIMESTAMP_OFFSET, messageInfo = null ) } /** * Converts a database Message to an assistant ChatMessageDto with full message info. * Requires a Json instance to parse the stored Claude response. */ fun Message.toAssistantMessageDto(json: Json): ChatMessageDto { val claudeResponse = json.decodeFromString<ClaudeResponse>(this.claude_response_json) val cost = calculateCost( model = claudeResponse.model ?: ClaudeModels.DEFAULT_MODEL, inputTokens = claudeResponse.usage?.inputTokens ?: 0, outputTokens = claudeResponse.usage?.outputTokens ?: 0 ) return ChatMessageDto( id = this.id, content = this.assistant_message, sender = MessageSender.ASSISTANT, timestamp = this.timestamp, messageInfo = MessageInfoDto( inputTokens = claudeResponse.usage?.inputTokens ?: 0, outputTokens = claudeResponse.usage?.outputTokens ?: 0, responseTimeMs = this.response_time_ms, model = claudeResponse.model ?: \"unknown\", cost = cost ) ) } /** * Converts a database Message to both user and assistant ChatMessageDto objects. * This is useful for loading chat history where we need both messages. */ fun Message.toBothMessageDtos(json: Json): Pair<ChatMessageDto, ChatMessageDto> { return Pair( toUserMessageDto(), toAssistantMessageDto(json) ) } /** * Calculates the cost of a Claude API call based on model and token usage. * Returns the total cost in dollars. */ fun calculateCost(model: String, inputTokens: Int, outputTokens: Int): Double { val pricing = when { model.contains(\"sonnet-4\") -> ClaudePricing.SONNET_4_PRICING model.contains(\"haiku-4\") -> ClaudePricing.HAIKU_4_PRICING else -> ClaudePricing.DEFAULT_PRICING } val inputCost = (inputTokens / ClaudePricing.TOKENS_PER_MILLION) * pricing.first val outputCost = (outputTokens / ClaudePricing.TOKENS_PER_MILLION) * pricing.second return inputCost + outputCost } /** * Creates a MessageInfoDto from Claude response and timing information. */ fun createMessageInfo( claudeResponse: ClaudeResponse, responseTimeMs: Long ): MessageInfoDto { val cost = calculateCost( model = claudeResponse.model ?: ClaudeModels.DEFAULT_MODEL, inputTokens = claudeResponse.usage?.inputTokens ?: 0, outputTokens = claudeResponse.usage?.outputTokens ?: 0 ) return MessageInfoDto( inputTokens = claudeResponse.usage?.inputTokens ?: 0, outputTokens = claudeResponse.usage?.outputTokens ?: 0, responseTimeMs = responseTimeMs, model = claudeResponse.model ?: \"unknown\", cost = cost ) }",
            "startTokenIndex": 0,
            "endTokenIndex": 343,
            "fileType": "kt"
        },
        {
            "chunkId": "e9e67b51-a267-4517-af50-94d207060de2",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/repository/ChatRepository.kt",
            "content": "package ru.alekseev.myapplication.repository import ru.alekseev.myapplication.db.Message import ru.alekseev.myapplication.db.Summary interface ChatRepository { suspend fun saveMessage( id: String, userMessage: String, assistantMessage: String, claudeResponseJson: String, timestamp: Long, responseTimeMs: Long, userId: String = \"default_user\" ) suspend fun getAllMessages(userId: String = \"default_user\"): List<Message> suspend fun getUncompressedMessages(userId: String = \"default_user\"): List<Message> suspend fun getUncompressedMessagesCount(userId: String = \"default_user\"): Long suspend fun markMessagesAsCompressed(messageIds: List<String>) suspend fun saveSummary( id: String, summaryText: String, messagesCount: Int, timestamp: Long, position: Int, userId: String = \"default_user\" ) suspend fun getAllSummaries(userId: String = \"default_user\"): List<Summary> suspend fun getMessageById(id: String): Message? }",
            "startTokenIndex": 0,
            "endTokenIndex": 85,
            "fileType": "kt"
        },
        {
            "chunkId": "6ef791a9-0100-49e1-84eb-b1503b86441a",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/repository/ChatRepositoryImpl.kt",
            "content": "package ru.alekseev.myapplication.repository import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import ru.alekseev.myapplication.db.ChatDatabase import ru.alekseev.myapplication.db.Message import ru.alekseev.myapplication.db.Summary class ChatRepositoryImpl( database: ChatDatabase, ) : ChatRepository { private val queries = database.chatDatabaseQueries override suspend fun saveMessage( id: String, userMessage: String, assistantMessage: String, claudeResponseJson: String, timestamp: Long, responseTimeMs: Long, userId: String, ) { withContext(Dispatchers.IO) { queries.insertMessage( id = id, user_message = userMessage, assistant_message = assistantMessage, claude_response_json = claudeResponseJson, timestamp = timestamp, response_time_ms = responseTimeMs, is_compressed = 0, user_id = userId ) } } override suspend fun getAllMessages(userId: String): List<Message> = withContext(Dispatchers.IO) { queries.getAllMessages(userId).executeAsList() } override suspend fun getUncompressedMessages(userId: String): List<Message> = withContext(Dispatchers.IO) { queries.getUncompressedMessages(userId).executeAsList() } override suspend fun getUncompressedMessagesCount(userId: String): Long = withContext(Dispatchers.IO) { queries.getUncompressedMessagesCount(userId).executeAsOne() } override suspend fun markMessagesAsCompressed(messageIds: List<String>) = withContext(Dispatchers.IO) { // SQLDelight doesn't support IN clause with parameters directly, so we need to update each message messageIds.forEach { id -> queries.transaction { queries.markMessagesAsCompressed(listOf(id)) } } } override suspend fun saveSummary( id: String, summaryText: String, messagesCount: Int, timestamp: Long, position: Int, userId: String, ) { withContext(Dispatchers.IO) { queries.insertSummary( id = id, summary_text = summaryText, messages_count = messagesCount.toLong(), timestamp = timestamp, position = position.toLong(), user_id = userId ) } } override suspend fun getAllSummaries(userId: String): List<Summary> = withContext(Dispatchers.IO) { queries.getAllSummaries(userId).executeAsList() } override suspend fun getMessageById(id: String): Message? = withContext(Dispatchers.IO) { queries.getMessageById(id).executeAsOneOrNull() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 207,
            "fileType": "kt"
        },
        {
            "chunkId": "c81e6783-9cfa-4cf8-b2c5-47ee0b17f498",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/routing/ChatRouting.kt",
            "content": "@file:OptIn(ExperimentalUuidApi::class) package ru.alekseev.myapplication.routing import io.ktor.server.routing.Route import io.ktor.server.websocket.webSocket import io.ktor.websocket.Frame import io.ktor.websocket.readText import kotlinx.coroutines.channels.consumeEach import kotlinx.serialization.json.Json import org.koin.java.KoinJavaComponent.inject import ru.alekseev.myapplication.core.common.ChatConstants import ru.alekseev.myapplication.data.dto.* import ru.alekseev.myapplication.usecase.HandleSummarizationUseCase import ru.alekseev.myapplication.usecase.LoadChatHistoryUseCase import ru.alekseev.myapplication.usecase.ProcessUserMessageUseCase import ru.alekseev.myapplication.service.WebSocketManager import kotlin.uuid.ExperimentalUuidApi import kotlin.uuid.Uuid /** * WebSocket route for chat functionality. * Handles: * - Loading and sending chat history on connection * - Receiving user messages * - Automatic summarization when threshold is reached * - Processing messages through Claude API * - Sending responses back to client */ fun Route.chatRouting() { // Inject dependencies val json: Json by inject(Json::class.java) val loadChatHistoryUseCase: LoadChatHistoryUseCase by inject(LoadChatHistoryUseCase::class.java) val handleSummarizationUseCase: HandleSummarizationUseCase by inject(HandleSummarizationUseCase::class.java) val processUserMessageUseCase: ProcessUserMessageUseCase by inject(ProcessUserMessageUseCase::class.java) val webSocketManager: WebSocketManager by inject(WebSocketManager::class.java) webSocket(\"/chat\") { val userId = ChatConstants.DEFAULT_USER_ID val connectionId = Uuid.random().toString() // Register this connection webSocketManager.registerConnection(connectionId, this) try { // Load and send chat history on connection val historyMessages = loadChatHistoryUseCase(userId) if (historyMessages.isNotEmpty()) { send( Frame.Text( json.encodeToString( ChatResponseDto.serializer(), ChatResponseDto.History(historyMessages) ) ) ) } // Process incoming messages incoming.consumeEach { frame -> if (frame is Frame.Text) { val text = frame.readText() try { val request = json.decodeFromString<ChatRequestDto>(text) // Send loading state send( Frame.Text( json.encodeToString( ChatResponseDto.serializer(), ChatResponseDto.Loading ) ) ) // Handle summarization if needed handleSummarizationUseCase(userId) // Process user message and get response val result = processUserMessageUseCase(request.message, userId) // Send user message send( Frame.Text( json.encodeToString( ChatResponseDto.serializer(), ChatResponseDto.Data(message = result.userMessage) ) ) ) // Send assistant response send( Frame.Text( json.encodeToString( ChatResponseDto.serializer(), ChatResponseDto.Data(message = result.assistantMessage) ) ) ) } catch (e: Exception) { e.printStackTrace() send( Frame.Text( json.encodeToString( ChatResponseDto.serializer(), ChatResponseDto.Error(error = e.message ?: \"Unknown error\") ) ) ) } } } } catch (e: Exception) { e.printStackTrace() } finally { // Unregister connection when WebSocket closes webSocketManager.unregisterConnection(connectionId) } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 274,
            "fileType": "kt"
        },
        {
            "chunkId": "78d7c9c3-387e-49d0-8506-89355715a800",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/ClaudeApiService.kt",
            "content": "package ru.alekseev.myapplication.service import io.ktor.client.HttpClient import io.ktor.client.call.body import io.ktor.client.engine.cio.CIO import io.ktor.client.plugins.HttpTimeout import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.logging.DEFAULT import io.ktor.client.plugins.logging.LogLevel import io.ktor.client.plugins.logging.Logger import io.ktor.client.plugins.logging.Logging import io.ktor.client.request.header import io.ktor.client.request.post import io.ktor.client.request.setBody import io.ktor.http.ContentType import io.ktor.http.contentType import io.ktor.serialization.kotlinx.json.json import kotlinx.serialization.json.Json import kotlinx.serialization.json.JsonObject import ru.alekseev.myapplication.data.dto.* class ClaudeApiService( private val json: Json, private val mcpManager: MCPManager, ) { private val apiKey: String by lazy { loadApiKey() } private val httpClient = HttpClient(CIO) { install(HttpTimeout) { requestTimeoutMillis = 60_000 // 60 seconds connectTimeoutMillis = 10_000 // 10 seconds socketTimeoutMillis = 60_000 // 60 seconds } install(ContentNegotiation) { json(this@ClaudeApiService.json) } install(Logging) { logger = Logger.DEFAULT level = LogLevel.INFO } } private var mcpInitialized = false private fun loadApiKey(): String { System.getenv(\"ANTHROPIC_API_KEY\")?.takeIf { it.isNotBlank() }?.let { return it } return \"\" } /** * Initialize MCP connections */ suspend fun initializeMCP() { if (!mcpInitialized) { println(\"Initializing MCP connections...\") mcpManager.connectAll() mcpInitialized = true println(\"MCP Manager initialized\") // Log available tools val tools = mcpManager.getAllTools() println(\"Available MCP tools (${tools.size}): ${tools.map { it.name }}\") } } /** * Get available MCP tools */ suspend fun getMCPTools(): List<ClaudeTool> { if (!mcpInitialized) { initializeMCP() } return mcpManager.getAllTools() } /** * Send a message to Claude API with MCP tools and handle tool calls */ suspend fun sendMessage(request: ClaudeRequest): ClaudeResponse { // Ensure MCP is initialized if (!mcpInitialized) { initializeMCP() } // Add MCP tools to the request if not already present val requestWithTools = if (request.tools == null) { val mcpTools = mcpManager.getAllTools() request.copy(tools = mcpTools) } else { request } // Send initial request var currentRequest = requestWithTools val conversationMessages = request.messages.toMutableList() while (true) { val response = try { val httpResponse = httpClient.post(\"https://api.anthropic.com/v1/messages\") { header(\"x-api-key\", apiKey) header(\"anthropic-version\", \"2023-06-01\") contentType(ContentType.Application.Json) setBody(currentRequest) } httpResponse.body<ClaudeResponse>() } catch (e: Exception) { throw Exception(\"Failed to call Claude API: ${e.message}\", e) } // Check if response contains tool_use val toolUses = response.content?.filter { it.type == \"tool_use\" } ?: emptyList() if (toolUses.isEmpty() || response.stopReason != \"tool_use\") { // No tool calls, return the response println(\"No more tool calls. Stop reason: ${response.stopReason}\") return response } println(\"Received ${toolUses.size} tool use(s): ${toolUses.map { it.name }}\") // Add assistant's response to conversation conversationMessages.add( ClaudeMessage( role = \"assistant\", content = ClaudeMessageContent.ContentBlocks(response.content ?: emptyList()) ) ) // Execute tool calls val toolResults = mutableListOf<ClaudeContent>() for (toolUse in toolUses) { val toolName = toolUse.name ?: continue val toolInput = toolUse.input val toolUseId = toolUse.id ?: continue try { println(\"Calling tool: $toolName with input: $toolInput\") val result = mcpManager.callTool(toolName, toolInput) println(\"Tool $toolName returned: ${result.take(200)}${if (result.length > 200) \"...\" else \"\"}\") toolResults.add( ClaudeContent( type = \"tool_result\", toolUseId = toolUseId, content = kotlinx.serialization.json.JsonPrimitive(result) ) ) } catch (e: Exception) { println(\"Tool $toolName failed with error: ${e.message}\") e.printStackTrace() toolResults.add( ClaudeContent( type = \"tool_result\", toolUseId = toolUseId, content = kotlinx.serialization.json.JsonPrimitive(\"Error: ${e.message}\"), isError = true ) ) } } // Add tool results to conversation conversationMessages.add( ClaudeMessage( role = \"user\", content = ClaudeMessageContent.ContentBlocks(toolResults) ) ) // Continue conversation with tool results currentRequest = currentRequest.copy(messages = conversationMessages) } } fun close() { httpClient.close() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 490,
            "fileType": "kt"
        },
        {
            "chunkId": "f780681c-e0be-48a7-901a-89ab0dc7dfa1",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/DocumentRAGService.kt",
            "content": "package ru.alekseev.myapplication.service import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import kotlinx.serialization.json.Json import ru.alekseev.indexer.data.index.VectorIndex import ru.alekseev.indexer.data.mcp.MCPClient import ru.alekseev.indexer.data.ollama.OllamaClient import ru.alekseev.indexer.domain.models.IndexMetadata import ru.alekseev.indexer.domain.pipeline.IndexingPipeline import java.io.File /** * RAG (Retrieval Augmented Generation) service for document search. * Provides semantic search over indexed project documents. */ class DocumentRAGService( private val indexPath: String = \"./faiss_index/project.index\", private val metadataPath: String = \"./faiss_index/metadata.json\", private val ollamaUrl: String = \"http://localhost:11434\", private val mcpUrl: String = \"http://localhost:8082\" ) { private val vectorIndex = VectorIndex() private val ollamaClient = OllamaClient(ollamaUrl, \"nomic-embed-text\") private val json = Json { ignoreUnknownKeys = true } private var metadata: IndexMetadata? = null private var isIndexLoaded = false /** * Initialize the service by loading the index from disk */ suspend fun initialize() { withContext(Dispatchers.IO) { val indexFile = File(indexPath) if (indexFile.exists()) { try { println(\"[DocumentRAGService] Loading index from ${indexFile.absolutePath}\") vectorIndex.load(indexFile) isIndexLoaded = true println(\"[DocumentRAGService] Index loaded successfully with ${vectorIndex.size()} vectors\") // Load metadata val metadataFile = File(metadataPath) if (metadataFile.exists()) { metadata = json.decodeFromString( IndexMetadata.serializer(), metadataFile.readText() ) println(\"[DocumentRAGService] Metadata loaded: ${metadata?.totalChunks} chunks from ${metadata?.totalFiles} files\") } } catch (e: Exception) { println(\"[DocumentRAGService] Warning: Failed to load index: ${e.message}\") isIndexLoaded = false } } else { println(\"[DocumentRAGService] Index not found at ${indexFile.absolutePath}\") println(\"[DocumentRAGService] You can create the index by calling reindex() or running the indexer manually\") isIndexLoaded = false } } } /** * Search for relevant documents based on a query */ suspend fun search(query: String, topK: Int = 5): List<SearchResult> { if (!isIndexLoaded) { println(\"[DocumentRAGService] Index not loaded, returning empty results\") return emptyList() } return withContext(Dispatchers.IO) { try { // Generate query embedding val queryEmbedding = ollamaClient.embed(query) // Search the index val results = vectorIndex.search(queryEmbedding, topK) // Convert to SearchResult with chunk content from metadata results.mapNotNull { result -> val chunkMetadata = metadata?.chunks?.find { it.chunkId == result.id } if (chunkMetadata != null) { SearchResult( similarity = result.similarity, filePath = chunkMetadata.filePath, content = chunkMetadata.content, fileType = chunkMetadata.fileType, startToken = chunkMetadata.startTokenIndex, endToken = chunkMetadata.endTokenIndex ) } else { null } } } catch (e: Exception) { println(\"[DocumentRAGService] Search failed: ${e.message}\") emptyList() } } } /** * Get context string from search results to add to Claude prompt */ suspend fun getContextForQuery(query: String, topK: Int = 5): String { val results = search(query, topK) if (results.isEmpty()) { return \"\" } return buildString { appendLine(\"Here is relevant context from the project codebase:\") appendLine() results.forEachIndexed { index, result -> appendLine(\"--- Document ${index + 1} (${result.filePath}, similarity: ${\"%.3f\".format(result.similarity)}) ---\") appendLine(result.content.take(1000)) // Limit to 1000 chars per chunk if (result.content.length > 1000) { appendLine(\"... (truncated)\") } appendLine() } appendLine(\"--- End of Context ---\") } } /** * Trigger re-indexing of the project */ suspend fun reindex() { withContext(Dispatchers.IO) { try { println(\"[DocumentRAGService] Starting re-indexing...\") val mcpClient = MCPClient(mcpUrl) val pipeline = IndexingPipeline( mcpClient = mcpClient, ollamaClient = ollamaClient, outputDir = File(indexPath).parent, chunkSize = 1024, overlapSize = 100 ) pipeline.run() mcpClient.close() // Reload the index initialize() println(\"[DocumentRAGService] Re-indexing completed\") } catch (e: Exception) { println(\"[DocumentRAGService] Re-indexing failed: ${e.message}\") throw e } } } /** * Check if the index is loaded and ready */ fun isReady(): Boolean = isIndexLoaded /** * Get index statistics */ fun getStats(): IndexStats { return IndexStats( isLoaded = isIndexLoaded, totalVectors = if (isIndexLoaded) vectorIndex.size() else 0, totalFiles = metadata?.totalFiles ?: 0, totalChunks = metadata?.totalChunks ?: 0, indexedAt = metadata?.indexedAt ) } fun close() { ollamaClient.close() } } /** * Result of a document search */ data class SearchResult( val similarity: Float, val filePath: String, val content: String, val fileType: String, val startToken: Int, val endToken: Int ) /** * Statistics about the loaded index */ data class IndexStats( val isLoaded: Boolean, val totalVectors: Int, val totalFiles: Int, val totalChunks: Int, val indexedAt: String? )",
            "startTokenIndex": 0,
            "endTokenIndex": 603,
            "fileType": "kt"
        },
        {
            "chunkId": "884f3c7a-4b0f-45f8-94a2-8965f0a895f7",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/MCPClient.kt",
            "content": "package ru.alekseev.myapplication.service import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.sync.Mutex import kotlinx.coroutines.sync.withLock import kotlinx.coroutines.withContext import kotlinx.serialization.json.Json import ru.alekseev.myapplication.data.dto.* import java.io.BufferedReader import java.io.BufferedWriter import java.io.InputStreamReader import java.io.OutputStreamWriter import java.util.concurrent.atomic.AtomicInteger /** * MCP Client for communicating with MCP servers via stdio. * * @param command Command to start the MCP server process * @param environment Environment variables for the MCP server process * @param workingDirectory Working directory for the MCP server process */ class MCPClient( private val name: String, private val command: List<String>, private val environment: Map<String, String> = emptyMap(), private val workingDirectory: String? = null ) { private var process: Process? = null private var writer: BufferedWriter? = null private var reader: BufferedReader? = null private var errorReader: BufferedReader? = null private val requestIdCounter = AtomicInteger(0) private val mutex = Mutex() private val json = Json { ignoreUnknownKeys = true encodeDefaults = true } var isConnected = false private set /** * Start the MCP server process and initialize the connection */ suspend fun connect(): MCPInitializeResult = withContext(Dispatchers.IO) { mutex.withLock { if (isConnected) { throw IllegalStateException(\"MCP client is already connected\") } // Start the process val processBuilder = ProcessBuilder(command).apply { environment().putAll(this@MCPClient.environment) workingDirectory?.let { directory(java.io.File(it)) } redirectErrorStream(false) } process = processBuilder.start() // Setup streams writer = BufferedWriter(OutputStreamWriter(process!!.outputStream)) reader = BufferedReader(InputStreamReader(process!!.inputStream)) errorReader = BufferedReader(InputStreamReader(process!!.errorStream)) // Start a thread to consume stderr to prevent buffer blocking Thread { try { errorReader?.forEachLine { line -> System.err.println(\"[$name stderr] $line\") } } catch (e: Exception) { System.err.println(\"[$name] Error reading stderr: ${e.message}\") } }.apply { isDaemon = true name = \"mcp-$name-stderr-reader\" start() } // Send initialize request val initParams = MCPInitializeParams( protocolVersion = \"2024-11-05\", capabilities = MCPClientCapabilities(), clientInfo = MCPClientInfo( name = name, version = \"1.0.0\" ) ) val initRequest = MCPRequest( id = requestIdCounter.incrementAndGet(), method = \"initialize\", params = json.encodeToJsonElement(MCPInitializeParams.serializer(), initParams) as kotlinx.serialization.json.JsonObject ) val response = sendRequestUnsafe(initRequest) response.error?.let { error -> disconnect() throw Exception(\"Failed to initialize MCP server: ${error.message}\") } val result = response.result?.let { json.decodeFromJsonElement(MCPInitializeResult.serializer(), it) } ?: throw Exception(\"No result in initialize response\") isConnected = true result } } /** * Get the list of available tools from the MCP server */ suspend fun listTools(): List<MCPTool> = withContext(Dispatchers.IO) { ensureConnected() val request = MCPRequest( id = requestIdCounter.incrementAndGet(), method = \"tools/list\", params = null ) val response = sendRequest(request) println(\"[$name] tools/list response: $response\") response.error?.let { error -> throw Exception(\"Failed to list tools: ${error.message}\") } val result = response.result?.let { println(\"[$name] tools/list result: $it\") json.decodeFromJsonElement(MCPListToolsResult.serializer(), it) } ?: throw Exception(\"No result in tools/list response\") result.tools } /** * Call a tool on the MCP server */ suspend fun callTool(toolName: String, arguments: kotlinx.serialization.json.JsonObject?): MCPCallToolResult = withContext(Dispatchers.IO) { ensureConnected() val params = json.encodeToJsonElement( MCPCallToolParams.serializer(), MCPCallToolParams(name = toolName, arguments = arguments) ) val request = MCPRequest( id = requestIdCounter.incrementAndGet(), method = \"tools/call\", params = params as kotlinx.serialization.json.JsonObject ) val response = sendRequest(request) response.error?.let { error -> throw Exception(\"Failed to call tool '$toolName': ${error.message}\") } response.result?.let { json.decodeFromJsonElement(MCPCallToolResult.serializer(), it) } ?: throw Exception(\"No result in tools/call response\") } /** * Send a request to the MCP server and wait for response * Protected by mutex to prevent concurrent access to writer/reader */ private suspend fun sendRequest(request: MCPRequest): MCPResponse = mutex.withLock { sendRequestUnsafe(request) } /** * Internal version of sendRequest without mutex protection. * Use this only when mutex is already held (e.g., inside connect()). */ private fun sendRequestUnsafe(request: MCPRequest): MCPResponse { val requestJson = json.encodeToString(MCPRequest.serializer(), request) // Write request writer?.write(requestJson) writer?.newLine() writer?.flush() // Read responses until we find the one matching our request ID // Skip notifications (messages with no id or method field) var maxAttempts = 50 // Prevent infinite loop while (maxAttempts-- > 0) { val responseLine = reader?.readLine() ?: throw Exception(\"Failed to read response from MCP server\") // Try to parse as JSON val response = try { json.decodeFromString(MCPResponse.serializer(), responseLine) } catch (e: Exception) { // If parsing fails, the server probably output non-JSON System.err.println(\"Failed to parse MCP response as JSON: $responseLine\") return MCPResponse( jsonrpc = \"2.0\", id = request.id, result = null, error = MCPError( code = -1, message = \"MCP server returned non-JSON response: ${responseLine.take(100)}\" ) ) } // Check if this is a notification (no id) - skip it if (response.id == null) { println(\"[$name] Skipping notification/message: ${responseLine.take(200)}\") continue } // Check if this response matches our request if (response.id == request.id) { return response } // This is a response for a different request - shouldn't happen but log it System.err.println(\"[$name] Received response for different request ID: ${response.id} (expected ${request.id})\") } throw Exception(\"Failed to receive matching response from MCP server after $maxAttempts attempts\") } /** * Disconnect from the MCP server and cleanup resources */ suspend fun disconnect() = withContext(Dispatchers.IO) { mutex.withLock { try { writer?.close() reader?.close() errorReader?.close() process?.destroy() process?.waitFor() } catch (e: Exception) { // Log but don't throw System.err.println(\"Error during MCP client disconnect: ${e.message}\") } finally { writer = null reader = null errorReader = null process = null isConnected = false } } } private fun ensureConnected() { if (!isConnected) { throw IllegalStateException(\"MCP client is not connected. Call connect() first.\") } } override fun toString(): String = \"MCPClient(name='$name', connected=$isConnected)\" }",
            "startTokenIndex": 0,
            "endTokenIndex": 836,
            "fileType": "kt"
        },
        {
            "chunkId": "f64fd412-f5cc-4d15-ba61-82b2a3004dc8",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/MCPHttpClient.kt",
            "content": "package ru.alekseev.myapplication.service import io.ktor.client.* import io.ktor.client.call.* import io.ktor.client.engine.cio.* import io.ktor.client.plugins.* import io.ktor.client.plugins.contentnegotiation.* import io.ktor.client.request.* import io.ktor.http.* import io.ktor.serialization.kotlinx.json.* import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.sync.Mutex import kotlinx.coroutines.sync.withLock import kotlinx.coroutines.withContext import kotlinx.serialization.json.Json import ru.alekseev.myapplication.data.dto.* import java.util.concurrent.atomic.AtomicInteger /** * HTTP-based MCP Client for communicating with MCP servers over HTTP. * Used for connecting to MCP servers running on the host machine from Docker. * * @param name Client name for logging * @param baseUrl Base URL of the MCP server (e.g., \"http://host.docker.internal:8082\") */ class MCPHttpClient( private val name: String, private val baseUrl: String ) { private val requestIdCounter = AtomicInteger(0) private val mutex = Mutex() private val json = Json { ignoreUnknownKeys = true encodeDefaults = true } private val httpClient = HttpClient(CIO) { install(ContentNegotiation) { json(this@MCPHttpClient.json) } // Configure timeouts for long-running operations like builds install(HttpTimeout) { requestTimeoutMillis = 600_000 // 10 minutes for builds connectTimeoutMillis = 10_000 // 10 seconds to connect socketTimeoutMillis = 600_000 // 10 minutes for socket read/write } // Configure engine timeouts engine { requestTimeout = 600_000 // 10 minutes } } var isConnected = false private set /** * Initialize the connection to the HTTP MCP server */ suspend fun connect(): MCPInitializeResult = withContext(Dispatchers.IO) { mutex.withLock { if (isConnected) { throw IllegalStateException(\"MCP HTTP client is already connected\") } // Check health endpoint first try { val healthResponse = httpClient.get(\"$baseUrl/health\") if (healthResponse.status != HttpStatusCode.OK) { throw Exception(\"Health check failed with status: ${healthResponse.status}\") } } catch (e: Exception) { throw Exception(\"Failed to connect to MCP server at $baseUrl: ${e.message}\") } // Send initialize request val initParams = MCPInitializeParams( protocolVersion = \"2024-11-05\", capabilities = MCPClientCapabilities(), clientInfo = MCPClientInfo( name = name, version = \"1.0.0\" ) ) val initRequest = MCPRequest( id = requestIdCounter.incrementAndGet(), method = \"initialize\", params = json.encodeToJsonElement(MCPInitializeParams.serializer(), initParams) as kotlinx.serialization.json.JsonObject ) val response = sendRequestUnsafe(initRequest) response.error?.let { error -> throw Exception(\"Failed to initialize MCP server: ${error.message}\") } val result = response.result?.let { json.decodeFromJsonElement(MCPInitializeResult.serializer(), it) } ?: throw Exception(\"No result in initialize response\") isConnected = true println(\"[$name] Successfully connected to HTTP MCP server at $baseUrl\") result } } /** * Get the list of available tools from the MCP server */ suspend fun listTools(): List<MCPTool> = withContext(Dispatchers.IO) { ensureConnected() val request = MCPRequest( id = requestIdCounter.incrementAndGet(), method = \"tools/list\", params = null ) val response = sendRequest(request) response.error?.let { error -> throw Exception(\"Failed to list tools: ${error.message}\") } val result = response.result?.let { json.decodeFromJsonElement(MCPListToolsResult.serializer(), it) } ?: throw Exception(\"No result in tools/list response\") result.tools } /** * Call a tool on the MCP server */ suspend fun callTool(toolName: String, arguments: kotlinx.serialization.json.JsonObject?): MCPCallToolResult = withContext(Dispatchers.IO) { ensureConnected() val params = json.encodeToJsonElement( MCPCallToolParams.serializer(), MCPCallToolParams(name = toolName, arguments = arguments) ) val request = MCPRequest( id = requestIdCounter.incrementAndGet(), method = \"tools/call\", params = params as kotlinx.serialization.json.JsonObject ) val response = sendRequest(request) response.error?.let { error -> throw Exception(\"Failed to call tool '$toolName': ${error.message}\") } response.result?.let { json.decodeFromJsonElement(MCPCallToolResult.serializer(), it) } ?: throw Exception(\"No result in tools/call response\") } /** * Send a request to the MCP server via HTTP and wait for response */ private suspend fun sendRequest(request: MCPRequest): MCPResponse = mutex.withLock { sendRequestUnsafe(request) } /** * Internal version of sendRequest without mutex protection */ private suspend fun sendRequestUnsafe(request: MCPRequest): MCPResponse { return try { val response = httpClient.post(\"$baseUrl/mcp\") { contentType(ContentType.Application.Json) setBody(request) } if (response.status != HttpStatusCode.OK) { MCPResponse( jsonrpc = \"2.0\", id = request.id, result = null, error = MCPError( code = response.status.value, message = \"HTTP error: ${response.status.description}\" ) ) } else { response.body<MCPResponse>() } } catch (e: Exception) { System.err.println(\"[$name] Error sending HTTP request: ${e.message}\") MCPResponse( jsonrpc = \"2.0\", id = request.id, result = null, error = MCPError( code = -1, message = \"HTTP request failed: ${e.message}\" ) ) } } /** * Disconnect from the MCP server */ suspend fun disconnect() = withContext(Dispatchers.IO) { mutex.withLock { try { httpClient.close() } catch (e: Exception) { System.err.println(\"[$name] Error during disconnect: ${e.message}\") } finally { isConnected = false } } } private fun ensureConnected() { if (!isConnected) { throw IllegalStateException(\"MCP HTTP client is not connected. Call connect() first.\") } } override fun toString(): String = \"MCPHttpClient(name='$name', baseUrl='$baseUrl', connected=$isConnected)\" }",
            "startTokenIndex": 0,
            "endTokenIndex": 674,
            "fileType": "kt"
        },
        {
            "chunkId": "70c1e55c-2e25-44f8-8ecf-0bd512410d63",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/MCPManager.kt",
            "content": "package ru.alekseev.myapplication.service import kotlinx.coroutines.sync.Mutex import kotlinx.coroutines.sync.withLock import ru.alekseev.myapplication.data.dto.ClaudeTool import ru.alekseev.myapplication.data.dto.MCPTool /** * Common interface for MCP clients (stdio and HTTP) */ interface IMCPClient { val isConnected: Boolean suspend fun connect(): Any suspend fun listTools(): List<MCPTool> suspend fun callTool(toolName: String, arguments: kotlinx.serialization.json.JsonObject?): ru.alekseev.myapplication.data.dto.MCPCallToolResult suspend fun disconnect() } /** * Manager for multiple MCP clients. * Handles connecting to MCP servers, collecting tools, and routing tool calls. */ class MCPManager { private val clients = mutableMapOf<String, IMCPClient>() private val toolToClient = mutableMapOf<String, String>() private val mutex = Mutex() /** * Register a stdio-based MCP client with a unique name */ fun registerClient(name: String, client: MCPClient) { clients[name] = object : IMCPClient { override val isConnected: Boolean get() = client.isConnected override suspend fun connect() = client.connect() override suspend fun listTools() = client.listTools() override suspend fun callTool(toolName: String, arguments: kotlinx.serialization.json.JsonObject?) = client.callTool(toolName, arguments) override suspend fun disconnect() { client.disconnect() } } } /** * Register an HTTP-based MCP client with a unique name */ fun registerHttpClient(name: String, client: MCPHttpClient) { clients[name] = object : IMCPClient { override val isConnected: Boolean get() = client.isConnected override suspend fun connect() = client.connect() override suspend fun listTools() = client.listTools() override suspend fun callTool(toolName: String, arguments: kotlinx.serialization.json.JsonObject?) = client.callTool(toolName, arguments) override suspend fun disconnect() = client.disconnect() } } /** * Connect to all registered MCP clients */ suspend fun connectAll() { mutex.withLock { clients.values.forEach { client -> try { client.connect() System.err.println(\"Successfully connected to MCP client: $client\") } catch (e: Exception) { System.err.println(\"Failed to connect to MCP client $client: ${e.message}\") e.printStackTrace() } } } } /** * Get all available tools from all connected MCP clients */ suspend fun getAllTools(): List<ClaudeTool> { val allTools = mutableListOf<ClaudeTool>() clients.forEach { (clientName, client) -> if (client.isConnected) { try { val mcpTools = client.listTools() mcpTools.forEach { mcpTool -> // Map tool to client for routing toolToClient[mcpTool.name] = clientName // Convert MCPTool to ClaudeTool allTools.add( ClaudeTool( name = mcpTool.name, description = mcpTool.description, inputSchema = mcpTool.inputSchema ) ) } } catch (e: Exception) { System.err.println(\"Failed to list tools from MCP client $clientName: ${e.message}\") e.printStackTrace() } } } return allTools } /** * Call a tool by routing to the appropriate MCP client */ suspend fun callTool(toolName: String, arguments: kotlinx.serialization.json.JsonObject?): String { val clientName = toolToClient[toolName] ?: throw IllegalArgumentException(\"Unknown tool: $toolName\") val client = clients[clientName] ?: throw IllegalStateException(\"MCP client not found: $clientName\") if (!client.isConnected) { throw IllegalStateException(\"MCP client is not connected: $clientName\") } val result = client.callTool(toolName, arguments) if (result.isError) { throw Exception(\"Tool call failed: ${result.content.firstOrNull()?.text ?: \"Unknown error\"}\") } return result.content.firstOrNull()?.text ?: \"\" } /** * Disconnect all MCP clients */ suspend fun disconnectAll() { mutex.withLock { clients.values.forEach { client -> try { client.disconnect() } catch (e: Exception) { System.err.println(\"Error disconnecting MCP client: ${e.message}\") } } toolToClient.clear() } } /** * Get information about registered clients */ fun getClientsInfo(): Map<String, Boolean> { return clients.mapValues { (_, client) -> client.isConnected } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 476,
            "fileType": "kt"
        },
        {
            "chunkId": "a40eefc0-54e8-4a7c-83a1-672fdb06b3d2",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/ReminderSchedulerService.kt",
            "content": "package ru.alekseev.myapplication.service import kotlinx.coroutines.* import kotlinx.coroutines.flow.MutableSharedFlow import kotlinx.coroutines.flow.asSharedFlow import ru.alekseev.myapplication.data.dto.AlertSeverityDto import ru.alekseev.myapplication.data.dto.UserAlertDto import java.util.UUID import kotlin.time.Duration.Companion.minutes import ru.alekseev.myapplication.data.dto.ClaudeRequest import ru.alekseev.myapplication.data.dto.ClaudeMessage import ru.alekseev.myapplication.data.dto.ClaudeMessageContent /** * Service that periodically generates reminder summaries * and broadcasts them to all connected clients */ class ReminderSchedulerService( private val claudeApiService: ClaudeApiService ) { private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob()) private var schedulerJob: Job? = null private val _alertFlow = MutableSharedFlow<UserAlertDto>(replay = 0) val alertFlow = _alertFlow.asSharedFlow() companion object { private val SCHEDULE_INTERVAL = 90.minutes } /** * Start the scheduler */ fun start() { if (schedulerJob?.isActive == true) { System.err.println(\"[ReminderScheduler] Scheduler is already running\") return } System.err.println(\"[ReminderScheduler] Starting scheduler with interval: $SCHEDULE_INTERVAL\") schedulerJob = scope.launch { while (isActive) { delay(SCHEDULE_INTERVAL) try { System.err.println(\"[ReminderScheduler] Generating reminder summary...\") generateAndBroadcastSummary() } catch (e: Exception) { System.err.println(\"[ReminderScheduler] Error generating summary: ${e.message}\") e.printStackTrace() } } } System.err.println(\"[ReminderScheduler] Scheduler started successfully\") } /** * Stop the scheduler */ fun stop() { System.err.println(\"[ReminderScheduler] Stopping scheduler...\") schedulerJob?.cancel() schedulerJob = null System.err.println(\"[ReminderScheduler] Scheduler stopped\") } /** * Generate summary and broadcast to all clients */ private suspend fun generateAndBroadcastSummary() { try { // Initialize MCP if needed claudeApiService.initializeMCP() // Ask Claude to get reminders summary // Claude will use the MCP tool \"get_reminders_summary\" automatically System.err.println(\"[ReminderScheduler] Asking Claude to get reminders summary...\") val request = ClaudeRequest( maxTokens = 1024, messages = listOf( ClaudeMessage( role = \"user\", content = ClaudeMessageContent.Text( \",     . \" + \"  get_reminders_summary   . \" + \"     .\" ) ) ) ) val response = claudeApiService.sendMessage(request) // Extract text from response val summaryText = response.content ?.firstOrNull { it.type == \"text\" } ?.text ?: \"   \" System.err.println(\"[ReminderScheduler] Summary result: ${summaryText.take(100)}\") // Create alert val alert = UserAlertDto( id = UUID.randomUUID().toString(), title = \"   \", message = summaryText, severity = AlertSeverityDto.INFO, category = \"reminder_summary\" ) // Broadcast alert to all clients _alertFlow.emit(alert) System.err.println(\"[ReminderScheduler] Alert broadcasted successfully\") } catch (e: Exception) { System.err.println(\"[ReminderScheduler] Error in generateAndBroadcastSummary: ${e.message}\") e.printStackTrace() // Send error alert val errorAlert = UserAlertDto( id = UUID.randomUUID().toString(), title = \"   \", message = \"     : ${e.message}\", severity = AlertSeverityDto.ERROR, category = \"reminder_error\" ) _alertFlow.emit(errorAlert) } } /** * Manually trigger summary generation */ suspend fun triggerManualSummary() { System.err.println(\"[ReminderScheduler] Manual summary triggered\") generateAndBroadcastSummary() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 381,
            "fileType": "kt"
        },
        {
            "chunkId": "2cf53966-7d18-4809-bc13-4cc0720e8f70",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/SummarizationService.kt",
            "content": "package ru.alekseev.myapplication.service import ru.alekseev.myapplication.data.dto.ClaudeMessage import ru.alekseev.myapplication.data.dto.ClaudeMessageContent import ru.alekseev.myapplication.data.dto.ClaudeRequest class SummarizationService( private val claudeApiService: ClaudeApiService, ) { suspend fun createSummary(messages: List<Pair<String, String>>): String { val conversationText = messages.mapIndexed { index, (userMsg, assistantMsg) -> \"\"\" Message ${index + 1}: User: $userMsg Assistant: $assistantMsg \"\"\".trimIndent() }.joinToString(\"\\n\\n\") val summaryPrompt = \"\"\" Please provide a concise summary of the following conversation. Focus on key facts, decisions, and context that would be important for continuing the conversation. Keep the summary brief but informative. Conversation: $conversationText Summary: \"\"\".trimIndent() val request = ClaudeRequest( messages = listOf( ClaudeMessage( role = \"user\", content = ClaudeMessageContent.Text(summaryPrompt) ) ) ) val response = claudeApiService.sendMessage(request) return response.content?.firstOrNull { it.type == \"text\" }?.text ?: \"Summary could not be generated\" } }",
            "startTokenIndex": 0,
            "endTokenIndex": 117,
            "fileType": "kt"
        },
        {
            "chunkId": "44a09c8c-330c-4a8c-8b32-2c8cb85e0b07",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/service/WebSocketManager.kt",
            "content": "package ru.alekseev.myapplication.service import io.ktor.websocket.DefaultWebSocketSession import io.ktor.websocket.Frame import kotlinx.coroutines.* import kotlinx.serialization.json.Json import ru.alekseev.myapplication.data.dto.ChatResponseDto import ru.alekseev.myapplication.data.dto.UserAlertDto import java.util.concurrent.ConcurrentHashMap /** * Manages WebSocket connections and broadcasts messages to all connected clients */ class WebSocketManager( private val json: Json, private val reminderScheduler: ReminderSchedulerService ) { private val connections = ConcurrentHashMap<String, DefaultWebSocketSession>() private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob()) private var alertListenerJob: Job? = null /** * Register a new WebSocket connection */ fun registerConnection(id: String, session: DefaultWebSocketSession) { connections[id] = session System.err.println(\"[WebSocketManager] Connection registered: $id (Total: ${connections.size})\") // Start alert listener if this is the first connection if (connections.size == 1 && alertListenerJob == null) { startAlertListener() } } /** * Unregister a WebSocket connection */ fun unregisterConnection(id: String) { connections.remove(id) System.err.println(\"[WebSocketManager] Connection unregistered: $id (Total: ${connections.size})\") // Stop alert listener if no more connections if (connections.isEmpty()) { stopAlertListener() } } /** * Broadcast an alert to all connected clients */ suspend fun broadcastAlert(alert: UserAlertDto) { System.err.println(\"[WebSocketManager] Encoding alert: $alert\") val message = json.encodeToString( ChatResponseDto.serializer(), ChatResponseDto.Alert(alert) ) System.err.println(\"[WebSocketManager] Encoded message: '$message'\") System.err.println(\"[WebSocketManager] Message length: ${message.length}\") val frame = Frame.Text(message) val deadConnections = mutableListOf<String>() connections.forEach { (id, session) -> try { session.send(frame) System.err.println(\"[WebSocketManager] Alert sent to connection: $id\") } catch (e: Exception) { System.err.println(\"[WebSocketManager] Failed to send alert to $id: ${e.message}\") e.printStackTrace() deadConnections.add(id) } } // Remove dead connections deadConnections.forEach { unregisterConnection(it) } System.err.println(\"[WebSocketManager] Alert broadcasted to ${connections.size} connections\") } /** * Start listening to alerts from ReminderScheduler */ private fun startAlertListener() { System.err.println(\"[WebSocketManager] Starting alert listener...\") alertListenerJob = scope.launch { reminderScheduler.alertFlow.collect { alert -> System.err.println(\"[WebSocketManager] Received alert: ${alert.title}\") broadcastAlert(alert) } } System.err.println(\"[WebSocketManager] Alert listener started\") } /** * Stop listening to alerts */ private fun stopAlertListener() { System.err.println(\"[WebSocketManager] Stopping alert listener...\") alertListenerJob?.cancel() alertListenerJob = null System.err.println(\"[WebSocketManager] Alert listener stopped\") } /** * Get number of active connections */ fun getConnectionCount(): Int = connections.size /** * Close all connections */ suspend fun closeAll() { System.err.println(\"[WebSocketManager] Clearing all connections...\") connections.clear() stopAlertListener() System.err.println(\"[WebSocketManager] All connections cleared\") } }",
            "startTokenIndex": 0,
            "endTokenIndex": 321,
            "fileType": "kt"
        },
        {
            "chunkId": "e3405236-5a16-47e4-95f3-ab27e53199b5",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/usecase/HandleSummarizationUseCase.kt",
            "content": "package ru.alekseev.myapplication.usecase import ru.alekseev.myapplication.core.common.ChatConstants import ru.alekseev.myapplication.repository.ChatRepository import ru.alekseev.myapplication.service.SummarizationService import java.util.UUID /** * Use case for handling automatic conversation summarization. * Checks if summarization is needed and performs it if the threshold is reached. */ class HandleSummarizationUseCase( private val chatRepository: ChatRepository, private val summarizationService: SummarizationService ) { /** * Checks if summarization is needed and performs it. * Summarization triggers when uncompressed messages reach the threshold. * * @param userId The user identifier * @return true if summarization was performed, false otherwise */ suspend operator fun invoke(userId: String): Boolean { val uncompressedCount = chatRepository.getUncompressedMessagesCount(userId) if (uncompressedCount < ChatConstants.SUMMARIZATION_THRESHOLD) { return false } return try { val uncompressedMessages = chatRepository.getUncompressedMessages(userId) // Create message pairs for summarization val messagePairs = uncompressedMessages.map { msg -> msg.user_message to msg.assistant_message } // Generate summary val summaryText = summarizationService.createSummary(messagePairs) // Save summary to database val summaries = chatRepository.getAllSummaries(userId) chatRepository.saveSummary( id = UUID.randomUUID().toString(), summaryText = summaryText, messagesCount = uncompressedCount.toInt(), timestamp = System.currentTimeMillis(), position = summaries.size, userId = userId ) // Mark messages as compressed chatRepository.markMessagesAsCompressed( uncompressedMessages.map { it.id } ) true } catch (e: Exception) { e.printStackTrace() false } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 183,
            "fileType": "kt"
        },
        {
            "chunkId": "f984523a-5f45-4301-ac06-6fcc5fc3d793",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/usecase/LoadChatHistoryUseCase.kt",
            "content": "package ru.alekseev.myapplication.usecase import kotlinx.serialization.json.Json import ru.alekseev.myapplication.data.dto.ChatMessageDto import ru.alekseev.myapplication.mapper.toBothMessageDtos import ru.alekseev.myapplication.repository.ChatRepository /** * Use case for loading chat history for a specific user. * Converts database messages to DTOs that can be sent to the client. */ class LoadChatHistoryUseCase( private val chatRepository: ChatRepository, private val json: Json ) { /** * Loads all messages for the given user and converts them to ChatMessageDto pairs. * Each database message produces both a user message and an assistant message. * * @param userId The user identifier * @return List of ChatMessageDto objects representing the conversation history */ suspend operator fun invoke(userId: String): List<ChatMessageDto> { val messages = chatRepository.getAllMessages(userId) return messages.flatMap { message -> val (userMessage, assistantMessage) = message.toBothMessageDtos(json) listOf(userMessage, assistantMessage) } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 120,
            "fileType": "kt"
        },
        {
            "chunkId": "a3f9d1b3-f8b5-43c5-bda9-323c6b3e97a1",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/usecase/ProcessUserMessageUseCase.kt",
            "content": "package ru.alekseev.myapplication.usecase import kotlinx.serialization.json.Json import ru.alekseev.myapplication.core.common.ChatConstants import ru.alekseev.myapplication.data.dto.* import ru.alekseev.myapplication.mapper.createMessageInfo import ru.alekseev.myapplication.repository.ChatRepository import ru.alekseev.myapplication.service.ClaudeApiService import ru.alekseev.myapplication.service.DocumentRAGService import java.util.UUID import kotlin.system.measureTimeMillis /** * Result of processing a user message, containing both user and assistant messages to send to client */ data class ProcessMessageResult( val userMessage: ChatMessageDto, val assistantMessage: ChatMessageDto ) /** * Use case for processing a user message through the Claude API. * Handles building context from summaries and uncompressed messages, * calling Claude API, and saving the result. */ class ProcessUserMessageUseCase( private val chatRepository: ChatRepository, private val claudeApiService: ClaudeApiService, private val documentRAGService: DocumentRAGService, private val json: Json ) { /** * Processes a user message by: * 1. Building message history from summaries and uncompressed messages * 2. Calling Claude API with the full context * 3. Saving the conversation to database * 4. Creating DTOs for the response * * @param userMessageText The message text from the user * @param userId The user identifier * @return ProcessMessageResult containing both user and assistant message DTOs */ suspend operator fun invoke( userMessageText: String, userId: String = ChatConstants.DEFAULT_USER_ID ): ProcessMessageResult { // Build message history for Claude API val messagesForApi = buildMessageHistory(userId, userMessageText) // Create Claude API request val claudeRequest = ClaudeRequest(messages = messagesForApi) // Call Claude API and measure time val claudeResponse: ClaudeResponse val responseTime = measureTimeMillis { claudeResponse = claudeApiService.sendMessage(claudeRequest) } // Extract text from response val responseText = claudeResponse.content ?.firstOrNull { it.type == \"text\" } ?.text ?: \"No response\" // Save to database val messageId = UUID.randomUUID().toString() val currentTimestamp = System.currentTimeMillis() chatRepository.saveMessage( id = messageId, userMessage = userMessageText, assistantMessage = responseText, claudeResponseJson = json.encodeToString(claudeResponse), timestamp = currentTimestamp, responseTimeMs = responseTime, userId = userId ) // Create DTOs for response val userMessage = ChatMessageDto( id = \"${messageId}${ChatConstants.USER_MESSAGE_ID_SUFFIX}\", content = userMessageText, sender = MessageSender.USER, timestamp = currentTimestamp - ChatConstants.USER_MESSAGE_TIMESTAMP_OFFSET, messageInfo = null ) val assistantMessage = ChatMessageDto( id = messageId, content = responseText, sender = MessageSender.ASSISTANT, timestamp = currentTimestamp, messageInfo = createMessageInfo(claudeResponse, responseTime) ) return ProcessMessageResult(userMessage, assistantMessage) } /** * Builds the message history for Claude API from summaries and uncompressed messages. * Summaries are added as context at the beginning of the conversation. * Also includes RAG context from relevant documents. */ private suspend fun buildMessageHistory(userId: String, currentMessage: String): List<ClaudeMessage> { val summaries = chatRepository.getAllSummaries(userId) val uncompressedMessages = chatRepository.getUncompressedMessages(userId) val messagesForApi = mutableListOf<ClaudeMessage>() // Add summaries as system context if (summaries.isNotEmpty()) { val summaryContext = summaries.joinToString(\"\\n\\n\") { \"Previous conversation summary: ${it.summary_text}\" } messagesForApi.add( ClaudeMessage( role = \"user\", content = ClaudeMessageContent.Text(summaryContext) ) ) messagesForApi.add( ClaudeMessage( role = \"assistant\", content = ClaudeMessageContent.Text(\"I understand the context from previous conversations.\") ) ) } // Add uncompressed messages uncompressedMessages.forEach { msg -> messagesForApi.add( ClaudeMessage(role = \"user\", content = ClaudeMessageContent.Text(msg.user_message)) ) messagesForApi.add( ClaudeMessage(role = \"assistant\", content = ClaudeMessageContent.Text(msg.assistant_message)) ) } // Add RAG context from document search if (documentRAGService.isReady()) { val ragContext = documentRAGService.getContextForQuery(currentMessage, topK = 3) if (ragContext.isNotBlank()) { messagesForApi.add( ClaudeMessage( role = \"user\", content = ClaudeMessageContent.Text(ragContext) ) ) messagesForApi.add( ClaudeMessage( role = \"assistant\", content = ClaudeMessageContent.Text(\"I understand. I'll use this context from the project codebase to answer your question.\") ) ) } } // Add current user message messagesForApi.add( ClaudeMessage(role = \"user\", content = ClaudeMessageContent.Text(currentMessage)) ) return messagesForApi } }",
            "startTokenIndex": 0,
            "endTokenIndex": 527,
            "fileType": "kt"
        },
        {
            "chunkId": "8ed63af5-89c0-4410-b874-ce73a7457f3f",
            "filePath": "server/src/main/kotlin/ru/alekseev/myapplication/Application.kt",
            "content": "package ru.alekseev.myapplication import io.ktor.serialization.kotlinx.json.json import io.ktor.server.application.Application import io.ktor.server.application.ApplicationCallPipeline import io.ktor.server.application.application import io.ktor.server.application.call import io.ktor.server.application.install import io.ktor.server.application.log import io.ktor.server.engine.embeddedServer import io.ktor.server.netty.Netty import io.ktor.server.plugins.calllogging.CallLogging import io.ktor.server.plugins.contentnegotiation.ContentNegotiation import io.ktor.server.plugins.cors.routing.CORS import io.ktor.server.plugins.doublereceive.DoubleReceive import io.ktor.server.request.httpMethod import io.ktor.server.request.path import io.ktor.server.request.receiveText import io.ktor.server.response.ApplicationSendPipeline import io.ktor.server.response.respondText import io.ktor.server.routing.get import io.ktor.server.routing.head import io.ktor.server.routing.routing import io.ktor.server.websocket.WebSockets import io.ktor.server.websocket.pingPeriod import io.ktor.server.websocket.timeout import kotlinx.serialization.json.Json import org.koin.core.context.startKoin import org.koin.java.KoinJavaComponent.inject import ru.alekseev.myapplication.core.common.SERVER_PORT import ru.alekseev.myapplication.di.appModules import ru.alekseev.myapplication.routing.chatRouting import ru.alekseev.myapplication.service.DocumentRAGService import ru.alekseev.myapplication.service.ReminderSchedulerService import kotlinx.coroutines.launch import kotlin.time.Duration.Companion.seconds fun main() { startKoin { modules(appModules) } embeddedServer( factory = Netty, port = SERVER_PORT, host = \"0.0.0.0\", module = Application::module, ) .start(wait = true) } fun Application.module() { val json: Json by inject(Json::class.java) install(DoubleReceive) install(CallLogging) { format { call -> val status = call.response.status() val httpMethod = call.request.httpMethod.value val userAgent = call.request.headers[\"User-Agent\"] val path = call.request.path() \"$httpMethod $path -> $status (User-Agent: $userAgent)\" } } intercept(ApplicationCallPipeline.Monitoring) { try { val requestBody = call.receiveText() if (requestBody.isNotEmpty()) { application.log.info(\"Request body: $requestBody\") } } catch (_: Exception) { } } sendPipeline.intercept(ApplicationSendPipeline.After) { message -> if (message is String) { application.log.info(\"Response body: $message\") } } install(WebSockets) { pingPeriod = 15.seconds timeout = 15.seconds maxFrameSize = Long.MAX_VALUE masking = false } install(ContentNegotiation) { json(json) } install(CORS) { anyHost() allowHeader(\"Content-Type\") } // Start reminder scheduler val reminderScheduler: ReminderSchedulerService by inject(ReminderSchedulerService::class.java) reminderScheduler.start() log.info(\"Reminder scheduler started\") // Initialize Document RAG Service val documentRAGService: DocumentRAGService by inject(DocumentRAGService::class.java) launch { try { log.info(\"Initializing Document RAG Service...\") documentRAGService.initialize() val stats = documentRAGService.getStats() if (stats.isLoaded) { log.info(\"Document RAG Service initialized successfully\") log.info(\" - Total vectors: ${stats.totalVectors}\") log.info(\" - Total files: ${stats.totalFiles}\") log.info(\" - Indexed at: ${stats.indexedAt}\") } else { log.info(\"Document index not found. RAG will be unavailable.\") log.info(\"To create the index, run: ./gradlew :server-doc-indexer:run\") } } catch (e: Exception) { log.error(\"Failed to initialize Document RAG Service: ${e.message}\") } } routing { get(\"/\") { call.respondText(\"Ktor: ${Greeting().greet()}\") } head(\"/\") { call.respondText(\"\") } chatRouting() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 300,
            "fileType": "kt"
        },
        {
            "chunkId": "1c4b2a5f-ff34-4713-a2b6-ebfe0faa72fb",
            "filePath": "server/src/main/resources/logback.xml",
            "content": "<configuration> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <encoder> <pattern>%d{YYYY-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> </encoder> </appender> <root level=\"INFO\"> <appender-ref ref=\"STDOUT\"/> </root> <!-- Application logs --> <logger name=\"ru.alekseev.myapplication\" level=\"DEBUG\"/> <!-- Ktor CallLogging --> <logger name=\"io.ktor.server.plugins.calllogging\" level=\"INFO\"/> <!-- Third-party libraries --> <logger name=\"org.eclipse.jetty\" level=\"INFO\"/> <logger name=\"io.netty\" level=\"INFO\"/> <logger name=\"io.ktor\" level=\"INFO\"/> </configuration>",
            "startTokenIndex": 0,
            "endTokenIndex": 47,
            "fileType": "xml"
        },
        {
            "chunkId": "c2d66752-e6ff-40a1-8eeb-be7c485cde7b",
            "filePath": "server/src/test/kotlin/ru/alekseev/myapplication/ApplicationTest.kt",
            "content": "package ru.alekseev.myapplication import io.ktor.client.request.* import io.ktor.client.statement.* import io.ktor.http.* import io.ktor.server.testing.* import kotlin.test.* class ApplicationTest { @Test fun testRoot() = testApplication { application { module() } val response = client.get(\"/\") assertEquals(HttpStatusCode.OK, response.status) assertEquals(\"Ktor: ${Greeting().greet()}\", response.bodyAsText()) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 36,
            "fileType": "kt"
        },
        {
            "chunkId": "422ac364-409b-4ec9-ac85-264a6b6de31e",
            "filePath": "server/build.gradle.kts",
            "content": "plugins { alias(libs.plugins.kotlinJvm) alias(libs.plugins.ktor) alias(libs.plugins.kotlinSerialization) alias(libs.plugins.sqldelight) application } group = \"ru.alekseev.myapplication\" version = \"1.0.0\" application { mainClass.set(\"ru.alekseev.myapplication.ApplicationKt\") val isDevelopment: Boolean = project.ext.has(\"development\") applicationDefaultJvmArgs = listOf(\"-Dio.ktor.development=$isDevelopment\") } dependencies { implementation(projects.shared) implementation(projects.coreCommon) implementation(projects.serverDocIndexer) implementation(libs.logback) // Ktor Server implementation(libs.ktor.serverCore) implementation(libs.ktor.serverNetty) implementation(libs.ktor.server.websockets) implementation(libs.ktor.server.contentNegotiation) implementation(libs.ktor.serialization.json) implementation(libs.ktor.server.cors) implementation(libs.ktor.server.callLogging) implementation(libs.ktor.server.doubleReceive) // Ktor Client implementation(libs.ktor.client.core) implementation(libs.ktor.client.cio) implementation(libs.ktor.client.contentNegotiation) implementation(libs.ktor.client.logging) // Serialization implementation(libs.serialization.json) // Coroutines implementation(libs.kotlinx.coroutines) // SQLDelight implementation(libs.sqldelight.driver.sqlite) implementation(libs.sqldelight.coroutinesExtensions) // Koin implementation(libs.koin.core) implementation(libs.koin.ktor) // Google Calendar API implementation(libs.google.api.client) implementation(libs.google.oauth.client) implementation(libs.google.api.calendar) // Tests testImplementation(libs.ktor.serverTestHost) testImplementation(libs.kotlin.testJunit) } sqldelight { databases { create(\"ChatDatabase\") { packageName.set(\"ru.alekseev.myapplication.db\") } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 86,
            "fileType": "kts"
        },
        {
            "chunkId": "0d6eb618-44a1-433a-b286-201442e9b210",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/data/index/VectorIndex.kt",
            "content": "package ru.alekseev.indexer.data.index import kotlinx.serialization.Serializable import kotlinx.serialization.json.Json import ru.alekseev.indexer.domain.models.DocumentChunk import java.io.File import kotlin.math.sqrt /** * Simple vector index for storing and searching document embeddings. * Provides FAISS-like functionality with disk persistence. */ class VectorIndex { private val vectors = mutableListOf<IndexedVector>() private val json = Json { prettyPrint = true encodeDefaults = true } /** * Add a document chunk with its embedding to the index */ fun add(chunk: DocumentChunk) { require(chunk.embedding != null) { \"Chunk must have an embedding\" } vectors.add( IndexedVector( id = chunk.id, embedding = chunk.embedding, metadata = VectorMetadata( filePath = chunk.filePath, startToken = chunk.startTokenIndex, endToken = chunk.endTokenIndex, fileType = chunk.fileType ) ) ) } /** * Add multiple chunks to the index */ fun addAll(chunks: List<DocumentChunk>) { chunks.forEach { add(it) } } /** * Search for similar vectors using cosine similarity */ fun search(queryEmbedding: List<Float>, topK: Int = 10): List<SearchResult> { if (vectors.isEmpty()) return emptyList() return vectors .map { vector -> val similarity = cosineSimilarity(queryEmbedding, vector.embedding) SearchResult( id = vector.id, similarity = similarity, metadata = vector.metadata ) } .sortedByDescending { it.similarity } .take(topK) } /** * Save the index to disk */ fun save(indexFile: File) { indexFile.parentFile?.mkdirs() val indexData = IndexData( version = \"1.0\", dimension = vectors.firstOrNull()?.embedding?.size ?: 0, count = vectors.size, vectors = vectors ) indexFile.writeText(json.encodeToString(IndexData.serializer(), indexData)) } /** * Load the index from disk */ fun load(indexFile: File) { if (!indexFile.exists()) { throw IllegalArgumentException(\"Index file does not exist: ${indexFile.absolutePath}\") } val indexData = json.decodeFromString(IndexData.serializer(), indexFile.readText()) vectors.clear() vectors.addAll(indexData.vectors) } /** * Get the number of vectors in the index */ fun size(): Int = vectors.size /** * Calculate cosine similarity between two vectors */ private fun cosineSimilarity(a: List<Float>, b: List<Float>): Float { require(a.size == b.size) { \"Vectors must have the same dimension\" } var dotProduct = 0f var normA = 0f var normB = 0f for (i in a.indices) { dotProduct += a[i] * b[i] normA += a[i] * a[i] normB += b[i] * b[i] } return dotProduct / (sqrt(normA) * sqrt(normB)) } } @Serializable private data class IndexData( val version: String, val dimension: Int, val count: Int, val vectors: List<IndexedVector> ) @Serializable data class IndexedVector( val id: String, val embedding: List<Float>, val metadata: VectorMetadata ) @Serializable data class VectorMetadata( val filePath: String, val startToken: Int, val endToken: Int, val fileType: String ) data class SearchResult( val id: String, val similarity: Float, val metadata: VectorMetadata )",
            "startTokenIndex": 0,
            "endTokenIndex": 389,
            "fileType": "kt"
        },
        {
            "chunkId": "9b1c0dab-47c0-4e72-b21e-02d5ca49e781",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/data/mcp/MCPClient.kt",
            "content": "package ru.alekseev.indexer.data.mcp import io.ktor.client.* import io.ktor.client.call.* import io.ktor.client.engine.cio.* import io.ktor.client.plugins.contentnegotiation.* import io.ktor.client.request.* import io.ktor.http.* import io.ktor.serialization.kotlinx.json.* import kotlinx.serialization.json.* /** * Client for communicating with the MCP server */ class MCPClient( private val baseUrl: String = \"http://localhost:8082\" ) { private val client = HttpClient(CIO) { install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true encodeDefaults = true }) } } private var requestId = 0L /** * List files and directories at the given path */ suspend fun listDirectory(path: String, recursive: Boolean = false): List<FileEntry> { val response = callTool( toolName = \"list_directory\", arguments = buildJsonObject { put(\"path\", path) put(\"recursive\", recursive) } ) // Parse the response text to extract file entries return parseDirectoryListing(response) } /** * Read the contents of a file */ suspend fun readFile(path: String): String { return callTool( toolName = \"read_file\", arguments = buildJsonObject { put(\"path\", path) } ) } /** * Call an MCP tool */ private suspend fun callTool(toolName: String, arguments: JsonObject): String { val requestBody = buildJsonObject { put(\"jsonrpc\", \"2.0\") put(\"method\", \"tools/call\") put(\"id\", ++requestId) putJsonObject(\"params\") { put(\"name\", toolName) put(\"arguments\", arguments) } } val response: JsonObject = client.post(\"$baseUrl/mcp\") { contentType(ContentType.Application.Json) setBody(requestBody) }.body() // Extract result from JSON-RPC response val result = response[\"result\"]?.jsonObject ?: throw Exception(\"No result in response: $response\") val content = result[\"content\"]?.jsonArray?.firstOrNull()?.jsonObject ?: throw Exception(\"No content in result: $result\") return content[\"text\"]?.jsonPrimitive?.content ?: throw Exception(\"No text in content: $content\") } /** * Parse directory listing text into FileEntry objects */ private fun parseDirectoryListing(listing: String): List<FileEntry> { val entries = mutableListOf<FileEntry>() val lines = listing.lines() for (line in lines) { // Parse lines like: \"FILE filename.kt 1 KB\" // or: \"DIR foldername -\" if (line.startsWith(\"FILE\") || line.startsWith(\"DIR\")) { val parts = line.split(Regex(\"\\\\s+\")) if (parts.size >= 2) { val type = parts[0] val name = parts[1] val isDirectory = type == \"DIR\" entries.add(FileEntry(name, isDirectory)) } } } return entries } fun close() { client.close() } } /** * Represents a file or directory entry */ data class FileEntry( val name: String, val isDirectory: Boolean )",
            "startTokenIndex": 0,
            "endTokenIndex": 326,
            "fileType": "kt"
        },
        {
            "chunkId": "5ad82322-7aa3-449e-8553-6d8e01f344de",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/data/ollama/OllamaClient.kt",
            "content": "package ru.alekseev.indexer.data.ollama import io.ktor.client.* import io.ktor.client.call.* import io.ktor.client.engine.cio.* import io.ktor.client.plugins.contentnegotiation.* import io.ktor.client.request.* import io.ktor.http.* import io.ktor.serialization.kotlinx.json.* import kotlinx.serialization.Serializable import kotlinx.serialization.json.Json /** * Client for Ollama API to generate embeddings */ class OllamaClient( private val baseUrl: String = \"http://localhost:11434\", private val model: String = \"nomic-embed-text\" ) { private val client = HttpClient(CIO) { install(ContentNegotiation) { json(Json { ignoreUnknownKeys = true encodeDefaults = true }) } } /** * Generate embedding for a single text */ suspend fun embed(text: String): List<Float> { val response: EmbeddingResponse = client.post(\"$baseUrl/api/embeddings\") { contentType(ContentType.Application.Json) setBody( EmbeddingRequest( model = model, prompt = text ) ) }.body() return response.embedding } /** * Generate embeddings for multiple texts (batch processing) */ suspend fun embedBatch(texts: List<String>): List<List<Float>> { return texts.map { embed(it) } } fun close() { client.close() } } @Serializable private data class EmbeddingRequest( val model: String, val prompt: String ) @Serializable private data class EmbeddingResponse( val embedding: List<Float> )",
            "startTokenIndex": 0,
            "endTokenIndex": 150,
            "fileType": "kt"
        },
        {
            "chunkId": "f14cbff4-3cb9-48b2-9ee2-2a159829bb73",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/domain/chunking/TextChunker.kt",
            "content": "package ru.alekseev.indexer.domain.chunking /** * Chunks text into overlapping segments based on token count. * Uses simple whitespace tokenization. */ class TextChunker( private val chunkSize: Int = 1024, private val overlapSize: Int = 100 ) { init { require(chunkSize > 0) { \"Chunk size must be positive\" } require(overlapSize >= 0) { \"Overlap size must be non-negative\" } require(overlapSize < chunkSize) { \"Overlap size must be less than chunk size\" } } /** * Split text into chunks with overlap. * Returns list of TextChunk objects with token indices. */ fun chunk(text: String): List<TextChunk> { val tokens = tokenize(text) if (tokens.isEmpty()) { return emptyList() } val chunks = mutableListOf<TextChunk>() var startIndex = 0 while (startIndex < tokens.size) { val endIndex = minOf(startIndex + chunkSize, tokens.size) val chunkTokens = tokens.subList(startIndex, endIndex) val chunkText = chunkTokens.joinToString(\" \") chunks.add( TextChunk( content = chunkText, startTokenIndex = startIndex, endTokenIndex = endIndex, tokenCount = chunkTokens.size ) ) // Move forward by (chunkSize - overlapSize) tokens // This ensures exactly overlapSize tokens overlap between chunks val step = chunkSize - overlapSize startIndex += step // Stop if we've reached the end if (endIndex >= tokens.size) break } return chunks } /** * Simple whitespace tokenization. * Splits on whitespace and filters out empty tokens. */ private fun tokenize(text: String): List<String> { return text.split(Regex(\"\\\\s+\")) .filter { it.isNotBlank() } } /** * Estimate token count for a text string */ fun estimateTokenCount(text: String): Int { return tokenize(text).size } } /** * Represents a chunk of text with its token boundaries */ data class TextChunk( val content: String, val startTokenIndex: Int, val endTokenIndex: Int, val tokenCount: Int )",
            "startTokenIndex": 0,
            "endTokenIndex": 267,
            "fileType": "kt"
        },
        {
            "chunkId": "a99cd49e-8313-4b51-9f00-4dfd1d106357",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/domain/crawler/FileCrawler.kt",
            "content": "package ru.alekseev.indexer.domain.crawler import ru.alekseev.indexer.data.mcp.MCPClient import ru.alekseev.indexer.domain.models.FileItem /** * Crawls the project directory structure via MCP server * to find all files matching the specified criteria. */ class FileCrawler( private val mcpClient: MCPClient ) { companion object { // Supported file extensions private val SUPPORTED_EXTENSIONS = setOf( \"kt\", \"kts\", \"gradle\", \"md\", \"txt\", \"java\", \"xml\" ) // Directories to exclude private val EXCLUDED_DIRS = setOf( \"build\", \".gradle\", \".git\", \".idea\", \"node_modules\" ) // Max file size (1 MB) private const val MAX_FILE_SIZE = 1 * 1024 * 1024L } /** * Crawl the entire project starting from the root */ suspend fun crawl(rootPath: String = \".\"): List<FileItem> { val files = mutableListOf<FileItem>() crawlDirectory(rootPath, files) return files } /** * Recursively crawl a directory */ private suspend fun crawlDirectory(path: String, accumulator: MutableList<FileItem>) { try { val entries = mcpClient.listDirectory(path, recursive = false) for (entry in entries) { val fullPath = if (path == \".\") entry.name else \"$path/${entry.name}\" if (entry.isDirectory) { // Skip excluded directories if (entry.name !in EXCLUDED_DIRS && !entry.name.startsWith(\".\")) { crawlDirectory(fullPath, accumulator) } } else { // Process file val extension = entry.name.substringAfterLast('.', \"\") if (extension in SUPPORTED_EXTENSIONS) { // We don't have size info from list_directory, so we'll check it during read accumulator.add( FileItem( path = fullPath, name = entry.name, sizeBytes = 0, // Will be checked during read extension = extension ) ) } } } } catch (e: Exception) { System.err.println(\"Warning: Failed to crawl directory $path: ${e.message}\") } } /** * Read and validate a file */ suspend fun readFile(fileItem: FileItem): String? { return try { val content = mcpClient.readFile(fileItem.path) // Check size after reading if (content.length > MAX_FILE_SIZE) { System.err.println(\"Skipping large file: ${fileItem.path} (${content.length} bytes)\") return null } content } catch (e: Exception) { System.err.println(\"Warning: Failed to read file ${fileItem.path}: ${e.message}\") null } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 296,
            "fileType": "kt"
        },
        {
            "chunkId": "cad0bd0d-4ef0-4f9a-b110-a639c99f5eec",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/domain/models/Models.kt",
            "content": "package ru.alekseev.indexer.domain.models import kotlinx.serialization.Serializable /** * Represents a document chunk with its metadata */ data class DocumentChunk( val id: String, val filePath: String, val content: String, val startTokenIndex: Int, val endTokenIndex: Int, val fileType: String, val embedding: List<Float>? = null ) /** * Metadata about indexed documents */ @Serializable data class IndexMetadata( val chunks: List<ChunkMetadata>, val totalFiles: Int, val totalChunks: Int, val indexedAt: String, val chunkSize: Int, val overlapSize: Int, val embeddingModel: String ) /** * Serializable chunk metadata */ @Serializable data class ChunkMetadata( val chunkId: String, val filePath: String, val content: String, val startTokenIndex: Int, val endTokenIndex: Int, val fileType: String ) /** * Represents a file to be processed */ data class FileItem( val path: String, val name: String, val sizeBytes: Long, val extension: String )",
            "startTokenIndex": 0,
            "endTokenIndex": 128,
            "fileType": "kt"
        },
        {
            "chunkId": "3ecc1376-ca4b-4211-873e-bb2a6073495e",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/domain/pipeline/IndexingPipeline.kt",
            "content": "package ru.alekseev.indexer.domain.pipeline import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import kotlinx.serialization.encodeToString import kotlinx.serialization.json.Json import ru.alekseev.indexer.data.index.VectorIndex import ru.alekseev.indexer.data.mcp.MCPClient import ru.alekseev.indexer.data.ollama.OllamaClient import ru.alekseev.indexer.domain.chunking.TextChunker import ru.alekseev.indexer.domain.crawler.FileCrawler import ru.alekseev.indexer.domain.models.ChunkMetadata import ru.alekseev.indexer.domain.models.DocumentChunk import ru.alekseev.indexer.domain.models.IndexMetadata import java.io.File import java.time.Instant import java.util.* /** * Main pipeline for indexing project documents. * Orchestrates the entire process from crawling to embedding to indexing. */ class IndexingPipeline( private val mcpClient: MCPClient, private val ollamaClient: OllamaClient, private val outputDir: String = \"./faiss_index\", private val chunkSize: Int = 1024, private val overlapSize: Int = 100 ) { private val textChunker = TextChunker(chunkSize, overlapSize) private val fileCrawler = FileCrawler(mcpClient) private val vectorIndex = VectorIndex() private val json = Json { prettyPrint = true } /** * Run the complete indexing pipeline */ suspend fun run() { println(\"=== Starting Document Indexing Pipeline ===\\n\") // Step 1: Crawl project files println(\"Step 1: Crawling project files...\") val files = fileCrawler.crawl(\".\") println(\"Found ${files.size} files to process\\n\") // Step 2: Read and chunk files println(\"Step 2: Reading and chunking files...\") val allChunks = mutableListOf<DocumentChunk>() var processedFiles = 0 for (file in files) { val content = fileCrawler.readFile(file) ?: continue processedFiles++ val chunks = textChunker.chunk(content) println(\" ${file.path}: ${chunks.size} chunks\") chunks.forEachIndexed { index, chunk -> val chunkId = \"${UUID.randomUUID()}\" allChunks.add( DocumentChunk( id = chunkId, filePath = file.path, content = chunk.content, startTokenIndex = chunk.startTokenIndex, endTokenIndex = chunk.endTokenIndex, fileType = file.extension ) ) } } println(\"\\nTotal chunks created: ${allChunks.size}\") println(\"Files processed: $processedFiles\\n\") // Step 3: Generate embeddings println(\"Step 3: Generating embeddings using Ollama (${ollamaClient})...\") val chunksWithEmbeddings = mutableListOf<DocumentChunk>() for ((index, chunk) in allChunks.withIndex()) { if (index > 0 && index % 10 == 0) { println(\" Progress: $index / ${allChunks.size}\") } try { val embedding = withContext(Dispatchers.IO) { ollamaClient.embed(chunk.content) } chunksWithEmbeddings.add(chunk.copy(embedding = embedding)) } catch (e: Exception) { System.err.println(\" Warning: Failed to embed chunk ${chunk.id}: ${e.message}\") } } println(\"Embeddings generated: ${chunksWithEmbeddings.size}\\n\") // Step 4: Build vector index println(\"Step 4: Building vector index...\") vectorIndex.addAll(chunksWithEmbeddings) println(\"Index size: ${vectorIndex.size()} vectors\\n\") // Step 5: Save to disk println(\"Step 5: Saving index to disk...\") val outputDirFile = File(outputDir) outputDirFile.mkdirs() val indexFile = File(outputDirFile, \"project.index\") vectorIndex.save(indexFile) println(\"Index saved to: ${indexFile.absolutePath}\") // Save metadata val metadataFile = File(outputDirFile, \"metadata.json\") val metadata = IndexMetadata( chunks = chunksWithEmbeddings.map { ChunkMetadata( chunkId = it.id, filePath = it.filePath, content = it.content, startTokenIndex = it.startTokenIndex, endTokenIndex = it.endTokenIndex, fileType = it.fileType ) }, totalFiles = processedFiles, totalChunks = chunksWithEmbeddings.size, indexedAt = Instant.now().toString(), chunkSize = chunkSize, overlapSize = overlapSize, embeddingModel = \"nomic-embed-text\" ) metadataFile.writeText(json.encodeToString(metadata)) println(\"Metadata saved to: ${metadataFile.absolutePath}\\n\") println(\"=== Indexing Complete ===\") println(\"Summary:\") println(\" Files processed: $processedFiles\") println(\" Total chunks: ${chunksWithEmbeddings.size}\") println(\" Chunk size: $chunkSize tokens\") println(\" Overlap: $overlapSize tokens\") println(\" Index location: ${indexFile.absolutePath}\") } }",
            "startTokenIndex": 0,
            "endTokenIndex": 428,
            "fileType": "kt"
        },
        {
            "chunkId": "c2bfdb42-f925-4568-aded-ad6850706bfa",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/Main.kt",
            "content": "package ru.alekseev.indexer import kotlinx.coroutines.runBlocking import ru.alekseev.indexer.data.mcp.MCPClient import ru.alekseev.indexer.data.ollama.OllamaClient import ru.alekseev.indexer.domain.pipeline.IndexingPipeline /** * Main entry point for the document indexing application. * * Usage: * ./gradlew :server-doc-indexer:run * * Prerequisites: * 1. MCP server must be running on http://localhost:8082 * 2. Ollama must be running on http://localhost:11434 * 3. nomic-embed-text model must be pulled in Ollama * * Output: * - ./faiss_index/project.index (vector index) * - ./faiss_index/metadata.json (chunk metadata) */ fun main(args: Array<String>) { val mcpUrl = args.getOrNull(0) ?: \"http://localhost:8082\" val ollamaUrl = args.getOrNull(1) ?: \"http://localhost:11434\" val outputDir = args.getOrNull(2) ?: \"./faiss_index\" val currentDir = System.getProperty(\"user.dir\") println(\"Document Indexing Pipeline\") println(\"===========================\") println(\"Working Directory: $currentDir\") println(\"MCP Server: $mcpUrl\") println(\"Ollama Server: $ollamaUrl\") println(\"Output Directory: $outputDir\") println() val mcpClient = MCPClient(mcpUrl) val ollamaClient = OllamaClient(ollamaUrl, \"nomic-embed-text\") try { runBlocking { // Test connections first println(\"Testing connections...\") try { mcpClient.listDirectory(\".\") println(\" MCP server is reachable\") } catch (e: Exception) { println(\" MCP server is not reachable: ${e.message}\") println(\" Please start the MCP server first:\") println(\" ./start-devops-mcp.sh\") return@runBlocking } try { ollamaClient.embed(\"test\") println(\" Ollama server is reachable\") } catch (e: Exception) { println(\" Ollama server is not reachable: ${e.message}\") println(\" Please ensure Ollama is running and the model is pulled:\") println(\" ollama pull nomic-embed-text\") return@runBlocking } println() // Run the indexing pipeline val pipeline = IndexingPipeline( mcpClient = mcpClient, ollamaClient = ollamaClient, outputDir = outputDir, chunkSize = 1024, overlapSize = 100 ) pipeline.run() } } finally { mcpClient.close() ollamaClient.close() } println(\"\\nDone!\") }",
            "startTokenIndex": 0,
            "endTokenIndex": 235,
            "fileType": "kt"
        },
        {
            "chunkId": "a3439cd2-0982-406f-b951-0627e4599d22",
            "filePath": "server-doc-indexer/src/main/kotlin/ru/alekseev/indexer/SearchExample.kt",
            "content": "package ru.alekseev.indexer import kotlinx.coroutines.runBlocking import ru.alekseev.indexer.data.index.VectorIndex import ru.alekseev.indexer.data.ollama.OllamaClient import java.io.File /** * Example: Search the indexed project using semantic similarity * * Usage: * ./gradlew :server-doc-indexer:runSearch --args=\"your search query\" */ fun main(args: Array<String>) { if (args.isEmpty()) { println(\"Usage: ./gradlew :server-doc-indexer:runSearch --args=\\\"your search query\\\"\") println(\"Example: ./gradlew :server-doc-indexer:runSearch --args=\\\"how to build android app\\\"\") return } val query = args.joinToString(\" \") val indexPath = \"./faiss_index/project.index\" println(\"Searching index for: \\\"$query\\\"\") println() if (!File(indexPath).exists()) { println(\"Error: Index not found at $indexPath\") println(\"Please run the indexer first: ./run-indexer.sh\") return } runBlocking { // Load the index val index = VectorIndex() index.load(File(indexPath)) println(\"Loaded index with ${index.size()} vectors\") println() // Generate query embedding val ollamaClient = OllamaClient() println(\"Generating query embedding...\") val queryEmbedding = ollamaClient.embed(query) println() // Search println(\"Searching for similar chunks...\") val results = index.search(queryEmbedding, topK = 5) println() // Display results println(\"Top ${results.size} results:\") println(\"=\" * 80) println() results.forEachIndexed { index, result -> println(\"${index + 1}. Similarity: ${\"%.4f\".format(result.similarity)}\") println(\" File: ${result.metadata.filePath}\") println(\" Tokens: ${result.metadata.startToken}-${result.metadata.endToken}\") println(\" Type: ${result.metadata.fileType}\") println() } ollamaClient.close() } } private operator fun String.times(n: Int) = repeat(n)",
            "startTokenIndex": 0,
            "endTokenIndex": 172,
            "fileType": "kt"
        },
        {
            "chunkId": "4c452a25-0279-46b3-929a-ac7bcfe9224f",
            "filePath": "server-doc-indexer/build.gradle.kts",
            "content": "plugins { alias(libs.plugins.kotlinJvm) alias(libs.plugins.kotlinSerialization) application `java-library` } group = \"ru.alekseev.indexer\" version = \"1.0.0\" application { mainClass.set(\"ru.alekseev.indexer.MainKt\") applicationDefaultJvmArgs = listOf( \"-DprojectRoot=${rootProject.projectDir.absolutePath}\" ) } tasks.named<JavaExec>(\"run\") { // Pass project root as working directory for file discovery workingDir = rootProject.projectDir } kotlin { jvmToolchain(17) compilerOptions { jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17) } } dependencies { // Serialization implementation(libs.serialization.json) // Coroutines implementation(libs.kotlinx.coroutines) // Ktor Client for HTTP requests (MCP + Ollama) implementation(libs.ktor.client.core) implementation(libs.ktor.client.cio) implementation(libs.ktor.client.contentNegotiation) implementation(libs.ktor.serialization.json) // Logging implementation(libs.logback) } // Create a separate fat JAR task for standalone execution tasks.register<Jar>(\"fatJar\") { group = \"build\" description = \"Create a fat JAR with all dependencies\" archiveClassifier.set(\"all\") manifest { attributes[\"Main-Class\"] = \"ru.alekseev.indexer.MainKt\" } duplicatesStrategy = DuplicatesStrategy.EXCLUDE from(sourceSets.main.get().output) dependsOn(configurations.runtimeClasspath) from({ configurations.runtimeClasspath.get().filter { it.name.endsWith(\"jar\") }.map { zipTree(it) } }) } // Task to run the search example tasks.register<JavaExec>(\"runSearch\") { group = \"application\" description = \"Search the indexed documents\" mainClass.set(\"ru.alekseev.indexer.SearchExampleKt\") classpath = sourceSets[\"main\"].runtimeClasspath workingDir = rootProject.projectDir }",
            "startTokenIndex": 0,
            "endTokenIndex": 143,
            "fileType": "kts"
        },
        {
            "chunkId": "f1d1958f-d866-48c1-b1e0-b134f6778773",
            "filePath": "shared/src/androidMain/kotlin/ru/alekseev/myapplication/data/datasource/WebSocketHttpClient.android.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import io.ktor.client.HttpClient import io.ktor.client.engine.okhttp.OkHttp import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.websocket.WebSockets import io.ktor.client.plugins.websocket.pingInterval import io.ktor.serialization.kotlinx.json.json import kotlinx.serialization.json.Json import kotlin.time.DurationUnit import kotlin.time.toDuration actual fun createHttpClient(json: Json): HttpClient = HttpClient(OkHttp) { install(WebSockets) { pingInterval = 20_000.toDuration(DurationUnit.MILLISECONDS) } install(ContentNegotiation) { json(json) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 39,
            "fileType": "kt"
        },
        {
            "chunkId": "d5b64e0a-a1f0-4ea6-9494-fee5a923cf3b",
            "filePath": "shared/src/androidMain/kotlin/ru/alekseev/myapplication/di/PlatformModule.android.kt",
            "content": "package ru.alekseev.myapplication.di import org.koin.android.ext.koin.androidContext import org.koin.dsl.module import ru.alekseev.myapplication.ActivityProvider import ru.alekseev.myapplication.AndroidNotificationPermissionController import ru.alekseev.myapplication.NotificationPermissionController import ru.alekseev.myapplication.service.AlertDispatcher import ru.alekseev.myapplication.service.createAlertDispatcher actual val platformModule = module { single<AlertDispatcher> { createAlertDispatcher(androidContext()) } single { ActivityProvider() } single<NotificationPermissionController> { AndroidNotificationPermissionController( activityProvider = get() ) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 39,
            "fileType": "kt"
        },
        {
            "chunkId": "7dd0a6e0-30a2-484d-b351-58f50f5373cb",
            "filePath": "shared/src/androidMain/kotlin/ru/alekseev/myapplication/service/AlertDispatcher.android.kt",
            "content": "package ru.alekseev.myapplication.service import android.Manifest import android.app.NotificationChannel import android.app.NotificationManager import android.content.Context import android.content.pm.PackageManager import android.os.Build import androidx.core.app.NotificationCompat import androidx.core.app.NotificationManagerCompat import androidx.core.content.ContextCompat import ru.alekseev.myapplication.data.dto.AlertDispatchResult import ru.alekseev.myapplication.data.dto.AlertSeverityDto import ru.alekseev.myapplication.data.dto.UserAlertDto /** * Android implementation of AlertDispatcher using system notifications */ class AndroidAlertDispatcher(private val context: Context) : AlertDispatcher { companion object { private const val CHANNEL_ID = \"reminder_alerts\" private const val CHANNEL_NAME = \"Reminder Alerts\" private const val CHANNEL_DESCRIPTION = \"Notifications for reminder summaries and updates\" } init { createNotificationChannel() } private fun createNotificationChannel() { if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { val importance = NotificationManager.IMPORTANCE_DEFAULT val channel = NotificationChannel(CHANNEL_ID, CHANNEL_NAME, importance).apply { description = CHANNEL_DESCRIPTION } val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager notificationManager.createNotificationChannel(channel) } } override suspend fun dispatch(alert: UserAlertDto): AlertDispatchResult { return try { if (!isAvailable()) { return AlertDispatchResult.Failure(\"Notifications not available\") } val notificationId = alert.id.hashCode() // Determine icon based on severity val icon = when (alert.severity) { AlertSeverityDto.ERROR -> android.R.drawable.ic_dialog_alert AlertSeverityDto.WARNING -> android.R.drawable.ic_dialog_info AlertSeverityDto.SUCCESS -> android.R.drawable.ic_dialog_info AlertSeverityDto.INFO -> android.R.drawable.ic_dialog_info } val builder = NotificationCompat.Builder(context, CHANNEL_ID) .setSmallIcon(icon) .setContentTitle(alert.title) .setContentText(alert.message) .setStyle(NotificationCompat.BigTextStyle().bigText(alert.message)) .setPriority(when (alert.severity) { AlertSeverityDto.ERROR -> NotificationCompat.PRIORITY_HIGH AlertSeverityDto.WARNING -> NotificationCompat.PRIORITY_DEFAULT AlertSeverityDto.SUCCESS -> NotificationCompat.PRIORITY_DEFAULT AlertSeverityDto.INFO -> NotificationCompat.PRIORITY_DEFAULT }) .setAutoCancel(true) // Add category if provided alert.category?.let { builder.setCategory(it) } // Check permission before showing notification if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) { if (ContextCompat.checkSelfPermission( context, Manifest.permission.POST_NOTIFICATIONS ) != PackageManager.PERMISSION_GRANTED ) { return AlertDispatchResult.Failure(\"Notification permission not granted\") } } with(NotificationManagerCompat.from(context)) { notify(notificationId, builder.build()) } AlertDispatchResult.Success } catch (e: Exception) { AlertDispatchResult.Failure(\"Failed to dispatch alert: ${e.message}\") } } override fun isAvailable(): Boolean { return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) { ContextCompat.checkSelfPermission( context, Manifest.permission.POST_NOTIFICATIONS ) == PackageManager.PERMISSION_GRANTED } else { true } } override suspend fun requestPermissions(): Boolean { // On Android 13+, permissions need to be requested from an Activity // This method just checks current status return isAvailable() } } // Factory function for Android actual fun createAlertDispatcher(context: Any?): AlertDispatcher { val androidContext = context as? Context ?: throw IllegalArgumentException( \"Android platform requires Context. Pass application context to createAlertDispatcher(context).\" ) return AndroidAlertDispatcher(androidContext) }",
            "startTokenIndex": 0,
            "endTokenIndex": 321,
            "fileType": "kt"
        },
        {
            "chunkId": "17f418dc-eebe-4345-9d27-c2ef5f8a2a31",
            "filePath": "shared/src/androidMain/kotlin/ru/alekseev/myapplication/ActivityProvider.kt",
            "content": "package ru.alekseev.myapplication import androidx.activity.ComponentActivity class ActivityProvider { private var activity: ComponentActivity? = null fun set(activity: ComponentActivity) { this.activity = activity } fun clear(activity: ComponentActivity) { if (this.activity === activity) { this.activity = null } } fun get(): ComponentActivity? = activity }",
            "startTokenIndex": 0,
            "endTokenIndex": 41,
            "fileType": "kt"
        },
        {
            "chunkId": "4c34c49a-b9bf-41d7-afb6-663fc006b216",
            "filePath": "shared/src/androidMain/kotlin/ru/alekseev/myapplication/AndroidNotificationPermissionController.kt",
            "content": "package ru.alekseev.myapplication import android.Manifest import android.content.pm.PackageManager import android.os.Build import androidx.activity.ComponentActivity import androidx.activity.result.ActivityResultLauncher import androidx.activity.result.contract.ActivityResultContracts import androidx.core.content.ContextCompat class AndroidNotificationPermissionController( private val activityProvider: ActivityProvider, ) : NotificationPermissionController { private var launcher: ActivityResultLauncher<String>? = null private fun ensureLauncher(activity: ComponentActivity) { if (launcher == null) { launcher = activity.registerForActivityResult( ActivityResultContracts.RequestPermission() ) {} } } override suspend fun requestPermissionIfNeeded() { val activity = activityProvider.get() ?: return if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) return ensureLauncher(activity) val granted = ContextCompat.checkSelfPermission( activity, Manifest.permission.POST_NOTIFICATIONS ) == PackageManager.PERMISSION_GRANTED if (!granted) { launcher?.launch(Manifest.permission.POST_NOTIFICATIONS) } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 83,
            "fileType": "kt"
        },
        {
            "chunkId": "c49d7941-afc5-4c8c-8fe1-088619279b03",
            "filePath": "shared/src/androidMain/kotlin/ru/alekseev/myapplication/Platform.android.kt",
            "content": "package ru.alekseev.myapplication import android.os.Build class AndroidPlatform : Platform { override val name: String = \"Android ${Build.VERSION.SDK_INT}\" } actual fun getPlatform(): Platform = AndroidPlatform()",
            "startTokenIndex": 0,
            "endTokenIndex": 23,
            "fileType": "kt"
        },
        {
            "chunkId": "d44f780a-8952-43fd-9ca0-6888302a0b4a",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/datasource/ChatWebSocketDataSource.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import kotlinx.coroutines.flow.Flow import ru.alekseev.myapplication.data.dto.ChatResponseDto interface ChatWebSocketDataSource { suspend fun connect() suspend fun disconnect() suspend fun sendMessage(message: String) fun observeMessages(): Flow<ChatResponseDto> fun isConnected(): Boolean }",
            "startTokenIndex": 0,
            "endTokenIndex": 26,
            "fileType": "kt"
        },
        {
            "chunkId": "98ef7723-ffa6-4d6d-ac92-d20be2b86121",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/datasource/ChatWebSocketDataSourceImpl.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import io.ktor.client.HttpClient import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.websocket.WebSockets import io.ktor.client.plugins.websocket.pingInterval import io.ktor.client.plugins.websocket.webSocketSession import io.ktor.serialization.kotlinx.json.json import io.ktor.websocket.Frame import io.ktor.websocket.WebSocketSession import io.ktor.websocket.close import io.ktor.websocket.readText import kotlinx.coroutines.channels.awaitClose import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.callbackFlow import kotlinx.coroutines.flow.consumeAsFlow import kotlinx.coroutines.flow.filterIsInstance import kotlinx.coroutines.flow.mapNotNull import kotlinx.coroutines.isActive import kotlinx.serialization.json.Json import ru.alekseev.myapplication.core.common.SERVER_WS_URL import ru.alekseev.myapplication.data.dto.ChatRequestDto import ru.alekseev.myapplication.data.dto.ChatResponseDto class ChatWebSocketDataSourceImpl( private val json: Json, ) : ChatWebSocketDataSource { private val serverUrl: String = SERVER_WS_URL private val client = createHttpClient(json) private var session: WebSocketSession? = null override suspend fun connect() { if (session != null && session?.isActive == true) { return } try { session = client.webSocketSession(serverUrl) } catch (e: Exception) { session = null } } override suspend fun disconnect() { try { session?.close() } catch (e: Exception) { } finally { session = null } } override suspend fun sendMessage(message: String) { val request = ChatRequestDto(message = message) val jsonString = try { val result = json.encodeToString(request) result } catch (e: Exception) { val manual = \"\"\"{\"message\":\"${message.replace(\"\\\"\", \"\\\\\\\"\")}\"}\"\"\" manual } try { session?.send(Frame.Text(jsonString)) } catch (e: Exception) { e.printStackTrace() } } override fun observeMessages(): Flow<ChatResponseDto> = callbackFlow { val webSocketSession = session ?: run { trySend( ChatResponseDto.Error( error = \"Failed to connect\", ) ) close(IllegalStateException(\"WebSocket not connected\")) return@callbackFlow } session = webSocketSession try { webSocketSession.incoming .consumeAsFlow() .filterIsInstance<Frame.Text>() .mapNotNull { frame -> val text = frame.readText() println(\"[ChatWebSocket] Received text: '$text'\") // Skip empty messages if (text.isBlank()) { println(\"[ChatWebSocket] Skipping empty message\") return@mapNotNull null } try { val decoded = json.decodeFromString( ChatResponseDto.serializer(), text ) println(\"[ChatWebSocket] Successfully decoded: $decoded\") decoded } catch (e: Exception) { println(\"[ChatWebSocket] Parse error: ${e.message}\") ChatResponseDto.Error( error = \"Failed to parse response: ${e.message}\\nJSON input: $text\", ) } } .collect { response -> trySend(response) } } catch (e: Exception) { trySend( ChatResponseDto.Error( error = \"WebSocket error: ${e.message}\", ) ) } finally { webSocketSession.close() } awaitClose { session = null } } override fun isConnected(): Boolean = session?.isActive == true }",
            "startTokenIndex": 0,
            "endTokenIndex": 307,
            "fileType": "kt"
        },
        {
            "chunkId": "d6968384-8bee-4d3f-adeb-e5ed211eddcc",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/datasource/WebSocketHttpClient.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import io.ktor.client.HttpClient import kotlinx.serialization.json.Json expect fun createHttpClient(json: Json): HttpClient",
            "startTokenIndex": 0,
            "endTokenIndex": 11,
            "fileType": "kt"
        },
        {
            "chunkId": "719cbca2-9737-4286-816f-b1bb0aee03b2",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/dto/AlertDto.kt",
            "content": "@file:OptIn(ExperimentalTime::class) package ru.alekseev.myapplication.data.dto import kotlinx.serialization.Serializable import kotlin.time.Clock import kotlin.time.ExperimentalTime /** * Data transfer object for user alerts/notifications * Platform-agnostic representation of an alert message */ @Serializable data class UserAlertDto( val id: String, val title: String, val message: String, val severity: AlertSeverityDto = AlertSeverityDto.INFO, val timestamp: Long = Clock.System.now().toEpochMilliseconds(), val category: String? = null, val actionLabel: String? = null, val actionData: String? = null ) @Serializable enum class AlertSeverityDto { INFO, WARNING, ERROR, SUCCESS } /** * Result of dispatching an alert */ sealed class AlertDispatchResult { data object Success : AlertDispatchResult() data class Failure(val reason: String) : AlertDispatchResult() }",
            "startTokenIndex": 0,
            "endTokenIndex": 99,
            "fileType": "kt"
        },
        {
            "chunkId": "84a85eeb-dbde-4e53-96c7-d5c1f4a42f7a",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/dto/ChatDto.kt",
            "content": "@file:OptIn(ExperimentalTime::class) package ru.alekseev.myapplication.data.dto import kotlinx.serialization.ExperimentalSerializationApi import kotlinx.serialization.SerialName import kotlinx.serialization.Serializable import kotlinx.serialization.json.JsonClassDiscriminator import kotlin.time.Clock import kotlin.time.ExperimentalTime /** * DTO for communication between frontend and backend via WebSocket * This DTO is used both on client and server side */ @Serializable data class ChatMessageDto( val id: String, val content: String, val sender: MessageSender, val timestamp: Long = Clock.System.now().toEpochMilliseconds(), val messageInfo: MessageInfoDto? = null ) @Serializable enum class MessageSender { USER, ASSISTANT } @Serializable data class ChatRequestDto( val message: String ) @OptIn(ExperimentalSerializationApi::class) @Serializable @JsonClassDiscriminator(\"type\") sealed interface ChatResponseDto { @Serializable @SerialName(\"loading\") data object Loading : ChatResponseDto @Serializable @SerialName(\"data\") data class Data(val message: ChatMessageDto) : ChatResponseDto @Serializable @SerialName(\"error\") data class Error(val error: String) : ChatResponseDto @Serializable @SerialName(\"history\") data class History(val messages: List<ChatMessageDto>) : ChatResponseDto @Serializable @SerialName(\"alert\") data class Alert(val alert: UserAlertDto) : ChatResponseDto } @Serializable data class MessageInfoDto( val inputTokens: Int, val outputTokens: Int, val responseTimeMs: Long, val model: String, val cost: Double )",
            "startTokenIndex": 0,
            "endTokenIndex": 149,
            "fileType": "kt"
        },
        {
            "chunkId": "6017afcf-e52f-4b38-bda7-35bd4eef5315",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/dto/ClaudeApiDto.kt",
            "content": "package ru.alekseev.myapplication.data.dto import kotlinx.serialization.SerialName import kotlinx.serialization.Serializable import kotlinx.serialization.json.JsonElement import kotlinx.serialization.json.JsonObject @Serializable data class ClaudeRequest( val model: String = \"claude-haiku-4-5-20251001\", // claude-sonnet-4-5-20250929 @SerialName(\"max_tokens\") val maxTokens: Int = 1024, val messages: List<ClaudeMessage>, val stream: Boolean = false, val tools: List<ClaudeTool>? = null, ) @Serializable data class ClaudeMessage( val role: String, // \"user\" or \"assistant\" val content: ClaudeMessageContent, ) @Serializable(with = ClaudeMessageContentSerializer::class) sealed class ClaudeMessageContent { @Serializable data class Text(val text: String) : ClaudeMessageContent() @Serializable data class ContentBlocks(val blocks: List<ClaudeContent>) : ClaudeMessageContent() } @Serializable data class ClaudeResponse( val id: String? = null, val type: String? = null, val role: String? = null, val content: List<ClaudeContent>? = null, val model: String? = null, @SerialName(\"stop_reason\") val stopReason: String? = null, @SerialName(\"stop_sequence\") val stopSequence: String? = null, val usage: ClaudeUsage? = null, ) @Serializable data class ClaudeContent( val type: String, val text: String? = null, val id: String? = null, val name: String? = null, val input: JsonObject? = null, @SerialName(\"tool_use_id\") val toolUseId: String? = null, val content: JsonElement? = null, @SerialName(\"is_error\") val isError: Boolean? = null, ) @Serializable data class ClaudeUsage( @SerialName(\"input_tokens\") val inputTokens: Int, @SerialName(\"output_tokens\") val outputTokens: Int, ) @Serializable data class ClaudeTool( val name: String, val description: String, @SerialName(\"input_schema\") val inputSchema: JsonObject, )",
            "startTokenIndex": 0,
            "endTokenIndex": 200,
            "fileType": "kt"
        },
        {
            "chunkId": "991c95a7-f952-470b-bd72-41c6781b4fe7",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/dto/ClaudeMessageContentSerializer.kt",
            "content": "package ru.alekseev.myapplication.data.dto import kotlinx.serialization.KSerializer import kotlinx.serialization.descriptors.SerialDescriptor import kotlinx.serialization.descriptors.buildClassSerialDescriptor import kotlinx.serialization.encoding.Decoder import kotlinx.serialization.encoding.Encoder import kotlinx.serialization.json.* object ClaudeMessageContentSerializer : KSerializer<ClaudeMessageContent> { override val descriptor: SerialDescriptor = buildClassSerialDescriptor(\"ClaudeMessageContent\") override fun serialize(encoder: Encoder, value: ClaudeMessageContent) { require(encoder is JsonEncoder) val element = when (value) { is ClaudeMessageContent.Text -> JsonPrimitive(value.text) is ClaudeMessageContent.ContentBlocks -> Json.encodeToJsonElement( value.blocks ) } encoder.encodeJsonElement(element) } override fun deserialize(decoder: Decoder): ClaudeMessageContent { require(decoder is JsonDecoder) val element = decoder.decodeJsonElement() return when (element) { is JsonPrimitive -> ClaudeMessageContent.Text(element.content) is JsonArray -> ClaudeMessageContent.ContentBlocks( Json.decodeFromJsonElement(element) ) else -> throw IllegalArgumentException(\"Unknown content type\") } } }",
            "startTokenIndex": 0,
            "endTokenIndex": 90,
            "fileType": "kt"
        },
        {
            "chunkId": "bfd4bcb3-9c25-471f-8ddf-eb6e9dcd50b6",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/data/dto/MCPDto.kt",
            "content": "package ru.alekseev.myapplication.data.dto import kotlinx.serialization.Serializable import kotlinx.serialization.json.JsonElement import kotlinx.serialization.json.JsonObject // JSON-RPC Request/Response Models for MCP @Serializable data class MCPRequest( val jsonrpc: String = \"2.0\", val id: Int? = null, val method: String, val params: JsonObject? = null ) @Serializable data class MCPResponse( val jsonrpc: String = \"2.0\", val id: Int? = null, val result: JsonElement? = null, val error: MCPError? = null ) @Serializable data class MCPError( val code: Int, val message: String, val data: JsonElement? = null ) // MCP Protocol Models @Serializable data class MCPClientInfo( val name: String, val version: String ) @Serializable data class MCPClientCapabilities( val experimental: JsonObject? = null, val sampling: JsonObject? = null ) @Serializable data class MCPInitializeParams( val protocolVersion: String = \"2024-11-05\", val capabilities: MCPClientCapabilities = MCPClientCapabilities(), val clientInfo: MCPClientInfo ) @Serializable data class MCPServerInfo( val name: String, val version: String ) @Serializable data class MCPServerCapabilities( val tools: JsonObject? = null ) @Serializable data class MCPInitializeResult( val protocolVersion: String = \"2024-11-05\", val serverInfo: MCPServerInfo, val capabilities: MCPServerCapabilities ) @Serializable data class MCPTool( val name: String, val description: String, val inputSchema: JsonObject ) @Serializable data class MCPListToolsResult( val tools: List<MCPTool> ) @Serializable data class MCPCallToolParams( val name: String, val arguments: JsonObject? = null ) @Serializable data class MCPTextContent( val type: String = \"text\", val text: String ) @Serializable data class MCPCallToolResult( val content: List<MCPTextContent>, val isError: Boolean = false )",
            "startTokenIndex": 0,
            "endTokenIndex": 224,
            "fileType": "kt"
        },
        {
            "chunkId": "413327d6-2afb-40a6-8167-4fba5f56c22a",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/di/PlatformModule.kt",
            "content": "package ru.alekseev.myapplication.di import org.koin.core.module.Module /** * Platform-specific module that provides platform-dependent dependencies * like AlertDispatcher and other platform-specific services. * * Each platform must provide its own implementation. */ expect val platformModule: Module",
            "startTokenIndex": 0,
            "endTokenIndex": 33,
            "fileType": "kt"
        },
        {
            "chunkId": "12063bce-3ae6-4013-a451-0e218331893c",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/service/AlertDispatcher.kt",
            "content": "package ru.alekseev.myapplication.service import ru.alekseev.myapplication.data.dto.AlertDispatchResult import ru.alekseev.myapplication.data.dto.UserAlertDto /** * Platform-agnostic interface for dispatching user alerts. * Implementations should handle platform-specific notification mechanisms: * - Android: System notifications or local notifications * - iOS: Local notifications or UNUserNotificationCenter * - Web/Desktop: In-app notifications (toast, snackbar, etc.) */ interface AlertDispatcher { /** * Dispatch an alert to the user * @param alert The alert to display * @return Result of the dispatch operation */ suspend fun dispatch(alert: UserAlertDto): AlertDispatchResult /** * Check if alert dispatching is available on this platform * @return true if alerts can be dispatched */ fun isAvailable(): Boolean /** * Request necessary permissions for alert dispatching (e.g., notification permissions) * @return true if permissions are granted or not required */ suspend fun requestPermissions(): Boolean } /** * Factory function to create platform-specific AlertDispatcher * Implementation should be provided in each platform's source set * @param context Platform-specific context (e.g., Android Context). Can be null for platforms that don't need it. */ expect fun createAlertDispatcher(context: Any? = null): AlertDispatcher",
            "startTokenIndex": 0,
            "endTokenIndex": 169,
            "fileType": "kt"
        },
        {
            "chunkId": "5992eac3-77fd-42f7-89bf-2d7fd965a0c5",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/Greeting.kt",
            "content": "package ru.alekseev.myapplication class Greeting { private val platform = getPlatform() fun greet(): String { return \"Hello, ${platform.name}!\" } }",
            "startTokenIndex": 0,
            "endTokenIndex": 19,
            "fileType": "kt"
        },
        {
            "chunkId": "3ae18868-cb33-47c1-8270-b2bb1b3c3d84",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/NotificationPermissionController.kt",
            "content": "package ru.alekseev.myapplication interface NotificationPermissionController { suspend fun requestPermissionIfNeeded() } class EmptyNotificationPermissionController : NotificationPermissionController { override suspend fun requestPermissionIfNeeded() {} }",
            "startTokenIndex": 0,
            "endTokenIndex": 20,
            "fileType": "kt"
        },
        {
            "chunkId": "e4bfc531-c1cb-46f7-90c1-8f002fa468ed",
            "filePath": "shared/src/commonMain/kotlin/ru/alekseev/myapplication/Platform.kt",
            "content": "package ru.alekseev.myapplication interface Platform { val name: String } expect fun getPlatform(): Platform",
            "startTokenIndex": 0,
            "endTokenIndex": 13,
            "fileType": "kt"
        },
        {
            "chunkId": "f0dd54ad-d65b-4f8c-9a03-7c2397e8c7fe",
            "filePath": "shared/src/commonTest/kotlin/ru/alekseev/myapplication/SharedCommonTest.kt",
            "content": "package ru.alekseev.myapplication import kotlin.test.Test import kotlin.test.assertEquals class SharedCommonTest { @Test fun example() { assertEquals(3, 1 + 2) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 19,
            "fileType": "kt"
        },
        {
            "chunkId": "30be268c-71dd-4385-971a-a52fdd0269e7",
            "filePath": "shared/src/iosMain/kotlin/ru/alekseev/myapplication/data/datasource/WebSocketHttpClient.ios.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import io.ktor.client.HttpClient import io.ktor.client.engine.darwin.Darwin import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.websocket.WebSockets import io.ktor.client.plugins.websocket.pingInterval import io.ktor.serialization.kotlinx.json.json import kotlinx.serialization.json.Json import kotlin.time.DurationUnit import kotlin.time.toDuration actual fun createHttpClient(json: Json): HttpClient = HttpClient(Darwin) { install(WebSockets) { pingInterval = 20_000.toDuration(DurationUnit.MILLISECONDS) } install(ContentNegotiation) { json(json) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 39,
            "fileType": "kt"
        },
        {
            "chunkId": "742a9502-c28e-4869-bf1d-d30c88ad4bf8",
            "filePath": "shared/src/iosMain/kotlin/ru/alekseev/myapplication/di/PlatformModule.ios.kt",
            "content": "package ru.alekseev.myapplication.di import org.koin.dsl.module import ru.alekseev.myapplication.EmptyNotificationPermissionController import ru.alekseev.myapplication.NotificationPermissionController import ru.alekseev.myapplication.service.AlertDispatcher import ru.alekseev.myapplication.service.createAlertDispatcher actual val platformModule = module { single<AlertDispatcher> { createAlertDispatcher() } single<NotificationPermissionController> { EmptyNotificationPermissionController() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 27,
            "fileType": "kt"
        },
        {
            "chunkId": "97260b07-67dc-4ca8-a1a7-e8889fee5501",
            "filePath": "shared/src/iosMain/kotlin/ru/alekseev/myapplication/service/AlertDispatcher.ios.kt",
            "content": "package ru.alekseev.myapplication.service import kotlinx.cinterop.ExperimentalForeignApi import platform.UserNotifications.* import platform.Foundation.NSUUID import ru.alekseev.myapplication.data.dto.AlertDispatchResult import ru.alekseev.myapplication.data.dto.AlertSeverityDto import ru.alekseev.myapplication.data.dto.UserAlertDto import kotlin.coroutines.resume import kotlin.coroutines.suspendCoroutine /** * iOS implementation of AlertDispatcher using UNUserNotificationCenter */ @OptIn(ExperimentalForeignApi::class) class IOSAlertDispatcher : AlertDispatcher { private val notificationCenter = UNUserNotificationCenter.currentNotificationCenter() override suspend fun dispatch(alert: UserAlertDto): AlertDispatchResult { return try { if (!isAvailable()) { return AlertDispatchResult.Failure(\"Notifications not available\") } // Create notification content val content = UNMutableNotificationContent().apply { setTitle(alert.title) setBody(alert.message) // Set sound based on severity when (alert.severity) { AlertSeverityDto.ERROR, AlertSeverityDto.WARNING -> { setSound(UNNotificationSound.defaultSound()) } else -> { setSound(UNNotificationSound.defaultSound()) } } // Set category if provided alert.category?.let { setCategoryIdentifier(it) } } // Create trigger (deliver immediately) val trigger = null // null means deliver immediately // Create request val identifier = alert.id.ifEmpty { NSUUID().UUIDString() } val request = UNNotificationRequest.requestWithIdentifier( identifier = identifier, content = content, trigger = trigger ) // Add notification request suspendCoroutine { continuation -> notificationCenter.addNotificationRequest(request) { error -> if (error != null) { continuation.resume( AlertDispatchResult.Failure(\"Failed to schedule notification: ${error.localizedDescription}\") ) } else { continuation.resume(AlertDispatchResult.Success) } } } } catch (e: Exception) { AlertDispatchResult.Failure(\"Failed to dispatch alert: ${e.message}\") } } override fun isAvailable(): Boolean { // Always return true, actual permission check happens in requestPermissions return true } override suspend fun requestPermissions(): Boolean { return suspendCoroutine { continuation -> notificationCenter.requestAuthorizationWithOptions( options = UNAuthorizationOptionAlert or UNAuthorizationOptionSound or UNAuthorizationOptionBadge ) { granted, error -> if (error != null) { continuation.resume(false) } else { continuation.resume(granted) } } } } } // Factory function for iOS actual fun createAlertDispatcher(context: Any?): AlertDispatcher { return IOSAlertDispatcher() }",
            "startTokenIndex": 0,
            "endTokenIndex": 250,
            "fileType": "kt"
        },
        {
            "chunkId": "6cc8fdbc-6d3c-43fa-8e55-edbefef16c79",
            "filePath": "shared/src/iosMain/kotlin/ru/alekseev/myapplication/Platform.ios.kt",
            "content": "package ru.alekseev.myapplication import platform.UIKit.UIDevice class IOSPlatform: Platform { override val name: String = UIDevice.currentDevice.systemName() + \" \" + UIDevice.currentDevice.systemVersion } actual fun getPlatform(): Platform = IOSPlatform()",
            "startTokenIndex": 0,
            "endTokenIndex": 26,
            "fileType": "kt"
        },
        {
            "chunkId": "6131f5d1-4672-4538-8634-8922c8c59a1d",
            "filePath": "shared/src/jsMain/kotlin/ru/alekseev/myapplication/data/datasource/WebSocketHttpClient.js.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import io.ktor.client.HttpClient import io.ktor.client.engine.js.Js import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.websocket.WebSockets import io.ktor.client.plugins.websocket.pingInterval import io.ktor.serialization.kotlinx.json.json import kotlinx.serialization.json.Json import kotlin.time.DurationUnit import kotlin.time.toDuration actual fun createHttpClient(json: Json): HttpClient = HttpClient(Js) { install(WebSockets) { pingInterval = 20_000.toDuration(DurationUnit.MILLISECONDS) } install(ContentNegotiation) { json(json) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 39,
            "fileType": "kt"
        },
        {
            "chunkId": "0d523dc3-1fd8-4c35-a8ba-e2157a5fa67f",
            "filePath": "shared/src/jsMain/kotlin/ru/alekseev/myapplication/di/PlatformModule.js.kt",
            "content": "package ru.alekseev.myapplication.di import org.koin.dsl.module import ru.alekseev.myapplication.EmptyNotificationPermissionController import ru.alekseev.myapplication.NotificationPermissionController import ru.alekseev.myapplication.service.AlertDispatcher import ru.alekseev.myapplication.service.createAlertDispatcher actual val platformModule = module { single<AlertDispatcher> { createAlertDispatcher() } single<NotificationPermissionController> { EmptyNotificationPermissionController() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 27,
            "fileType": "kt"
        },
        {
            "chunkId": "be148e28-07cf-4750-ad71-6cbfa90290e7",
            "filePath": "shared/src/jsMain/kotlin/ru/alekseev/myapplication/service/AlertDispatcher.js.kt",
            "content": "package ru.alekseev.myapplication.service import ru.alekseev.myapplication.data.dto.AlertDispatchResult import ru.alekseev.myapplication.data.dto.UserAlertDto /** * Web (JS) implementation of AlertDispatcher * Uses a callback mechanism to display in-app notifications */ class WebAlertDispatcher( private val onAlertCallback: (UserAlertDto) -> Unit ) : AlertDispatcher { override suspend fun dispatch(alert: UserAlertDto): AlertDispatchResult { return try { onAlertCallback(alert) AlertDispatchResult.Success } catch (e: Exception) { AlertDispatchResult.Failure(\"Failed to dispatch alert: ${e.message}\") } } override fun isAvailable(): Boolean { return true // Always available for web in-app notifications } override suspend fun requestPermissions(): Boolean { return true // No permissions needed for in-app notifications } } // Factory function for Web (JS) actual fun createAlertDispatcher(context: Any?): AlertDispatcher { return WebAlertDispatcher { alert -> console.log(\"Alert received: ${alert.title} - ${alert.message}\") // In actual implementation, this would be connected to a state flow or UI component } }",
            "startTokenIndex": 0,
            "endTokenIndex": 130,
            "fileType": "kt"
        },
        {
            "chunkId": "130ff1f6-7578-4905-846b-db366cae3abe",
            "filePath": "shared/src/jsMain/kotlin/ru/alekseev/myapplication/Platform.js.kt",
            "content": "package ru.alekseev.myapplication class JsPlatform: Platform { override val name: String = \"Web with Kotlin/JS\" } actual fun getPlatform(): Platform = JsPlatform()",
            "startTokenIndex": 0,
            "endTokenIndex": 21,
            "fileType": "kt"
        },
        {
            "chunkId": "ba6fe1d2-67af-47da-8a44-771145c5e6f5",
            "filePath": "shared/src/jvmMain/kotlin/ru/alekseev/myapplication/data/datasource/WebSocketHttpClient.jvm.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import io.ktor.client.HttpClient import io.ktor.client.engine.cio.CIO import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.websocket.WebSockets import io.ktor.client.plugins.websocket.pingInterval import io.ktor.serialization.kotlinx.json.json import kotlinx.serialization.json.Json import kotlin.time.DurationUnit import kotlin.time.toDuration actual fun createHttpClient(json: Json): HttpClient = HttpClient(CIO) { install(WebSockets) { pingInterval = 20_000.toDuration(DurationUnit.MILLISECONDS) } install(ContentNegotiation) { json(json) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 39,
            "fileType": "kt"
        },
        {
            "chunkId": "74e6297c-bdd8-474e-8f35-195c933d9970",
            "filePath": "shared/src/jvmMain/kotlin/ru/alekseev/myapplication/di/PlatformModule.jvm.kt",
            "content": "package ru.alekseev.myapplication.di import org.koin.dsl.module import ru.alekseev.myapplication.EmptyNotificationPermissionController import ru.alekseev.myapplication.NotificationPermissionController import ru.alekseev.myapplication.service.AlertDispatcher import ru.alekseev.myapplication.service.createAlertDispatcher actual val platformModule = module { single<AlertDispatcher> { createAlertDispatcher() } single<NotificationPermissionController> { EmptyNotificationPermissionController() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 27,
            "fileType": "kt"
        },
        {
            "chunkId": "e83fc07f-ecce-4a10-a152-401252dd3b90",
            "filePath": "shared/src/jvmMain/kotlin/ru/alekseev/myapplication/service/AlertDispatcher.jvm.kt",
            "content": "package ru.alekseev.myapplication.service import ru.alekseev.myapplication.data.dto.AlertDispatchResult import ru.alekseev.myapplication.data.dto.UserAlertDto /** * JVM (Desktop) implementation of AlertDispatcher * Uses a callback mechanism to display in-app notifications */ class DesktopAlertDispatcher( private val onAlertCallback: (UserAlertDto) -> Unit ) : AlertDispatcher { override suspend fun dispatch(alert: UserAlertDto): AlertDispatchResult { return try { onAlertCallback(alert) AlertDispatchResult.Success } catch (e: Exception) { AlertDispatchResult.Failure(\"Failed to dispatch alert: ${e.message}\") } } override fun isAvailable(): Boolean { return true // Always available for desktop in-app notifications } override suspend fun requestPermissions(): Boolean { return true // No permissions needed for in-app notifications } } // Factory function for Desktop (JVM) actual fun createAlertDispatcher(context: Any?): AlertDispatcher { return DesktopAlertDispatcher { alert -> println(\"Alert received: ${alert.title} - ${alert.message}\") // In actual implementation, this would be connected to a state flow or UI component } }",
            "startTokenIndex": 0,
            "endTokenIndex": 130,
            "fileType": "kt"
        },
        {
            "chunkId": "a8d70b86-ee99-4070-8ab2-6dea5f71726f",
            "filePath": "shared/src/jvmMain/kotlin/ru/alekseev/myapplication/Platform.jvm.kt",
            "content": "package ru.alekseev.myapplication class JVMPlatform: Platform { override val name: String = \"Java ${System.getProperty(\"java.version\")}\" } actual fun getPlatform(): Platform = JVMPlatform()",
            "startTokenIndex": 0,
            "endTokenIndex": 20,
            "fileType": "kt"
        },
        {
            "chunkId": "29a4481e-e806-4db1-b984-2279a4fe465a",
            "filePath": "shared/src/wasmJsMain/kotlin/ru/alekseev/myapplication/data/datasource/WebSocketHttpClient.wasmJs.kt",
            "content": "package ru.alekseev.myapplication.data.datasource import io.ktor.client.HttpClient import io.ktor.client.engine.js.Js import io.ktor.client.plugins.contentnegotiation.ContentNegotiation import io.ktor.client.plugins.websocket.WebSockets import io.ktor.client.plugins.websocket.pingInterval import io.ktor.serialization.kotlinx.json.json import kotlinx.serialization.json.Json import kotlin.time.DurationUnit import kotlin.time.toDuration actual fun createHttpClient(json: Json): HttpClient = HttpClient(Js) { install(WebSockets) { pingInterval = 20_000.toDuration(DurationUnit.MILLISECONDS) } install(ContentNegotiation) { json(json) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 39,
            "fileType": "kt"
        },
        {
            "chunkId": "bddb2ea6-9280-4990-9c95-5ce42fffb700",
            "filePath": "shared/src/wasmJsMain/kotlin/ru/alekseev/myapplication/di/PlatformModule.wasmJs.kt",
            "content": "package ru.alekseev.myapplication.di import org.koin.dsl.module import ru.alekseev.myapplication.EmptyNotificationPermissionController import ru.alekseev.myapplication.NotificationPermissionController import ru.alekseev.myapplication.service.AlertDispatcher import ru.alekseev.myapplication.service.createAlertDispatcher actual val platformModule = module { single<AlertDispatcher> { createAlertDispatcher() } single<NotificationPermissionController> { EmptyNotificationPermissionController() } }",
            "startTokenIndex": 0,
            "endTokenIndex": 27,
            "fileType": "kt"
        },
        {
            "chunkId": "389f29dc-17e5-4a14-aa33-e54e7036c6a3",
            "filePath": "shared/src/wasmJsMain/kotlin/ru/alekseev/myapplication/service/AlertDispatcher.wasmJs.kt",
            "content": "package ru.alekseev.myapplication.service import ru.alekseev.myapplication.data.dto.AlertDispatchResult import ru.alekseev.myapplication.data.dto.UserAlertDto /** * Web (WasmJS) implementation of AlertDispatcher * Uses a callback mechanism to display in-app notifications */ class WasmWebAlertDispatcher( private val onAlertCallback: (UserAlertDto) -> Unit ) : AlertDispatcher { override suspend fun dispatch(alert: UserAlertDto): AlertDispatchResult { return try { onAlertCallback(alert) AlertDispatchResult.Success } catch (e: Exception) { AlertDispatchResult.Failure(\"Failed to dispatch alert: ${e.message}\") } } override fun isAvailable(): Boolean { return true // Always available for web in-app notifications } override suspend fun requestPermissions(): Boolean { return true // No permissions needed for in-app notifications } } // Factory function for Web (WasmJS) actual fun createAlertDispatcher(context: Any?): AlertDispatcher { return WasmWebAlertDispatcher { alert -> // TODO: Connect to state flow or UI component to display alerts // Alert received: ${alert.title} - ${alert.message} } }",
            "startTokenIndex": 0,
            "endTokenIndex": 128,
            "fileType": "kt"
        },
        {
            "chunkId": "b9b8f9cb-5a1c-4d1a-b06b-5136e49e5cea",
            "filePath": "shared/src/wasmJsMain/kotlin/ru/alekseev/myapplication/Platform.wasmJs.kt",
            "content": "package ru.alekseev.myapplication class WasmPlatform: Platform { override val name: String = \"Web with Kotlin/Wasm\" } actual fun getPlatform(): Platform = WasmPlatform()",
            "startTokenIndex": 0,
            "endTokenIndex": 21,
            "fileType": "kt"
        },
        {
            "chunkId": "5bb71b75-6cc5-4949-9249-87dbaa5c7787",
            "filePath": "shared/build.gradle.kts",
            "content": "import org.jetbrains.kotlin.gradle.ExperimentalWasmDsl import org.jetbrains.kotlin.gradle.dsl.JvmTarget plugins { alias(libs.plugins.kotlinMultiplatform) alias(libs.plugins.androidLibrary) alias(libs.plugins.kotlinSerialization) } kotlin { applyDefaultHierarchyTemplate() androidTarget { compilerOptions { jvmTarget.set(JvmTarget.fromTarget(libs.versions.jvmTarget.get())) } } listOf( iosArm64(), iosSimulatorArm64(), ) .forEach { it.binaries.framework { baseName = \"ComposeApp\" export(libs.decompose.decompose) export(libs.essenty.lifecycle) } } jvm() js { browser() } @OptIn(ExperimentalWasmDsl::class) wasmJs { browser() } sourceSets { commonMain.dependencies { // Core Common implementation(projects.coreCommon) // Decompose api(libs.decompose.decompose) api(libs.essenty.lifecycle) // Serialization for navigation implementation(libs.serialization.json) //DateTime implementation(libs.kotlinx.datetime) // Ktor Client implementation(libs.ktor.client.core) implementation(libs.ktor.client.websockets) implementation(libs.ktor.client.contentNegotiation) implementation(libs.ktor.serialization.json) //Koin implementation(libs.koin.core) } val androidMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.okhttp) implementation(libs.androidx.core.ktx) //Koin implementation(libs.koin.android) } } val jvmMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.cio) } } val iosMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.darwin) } } val jsMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.js) } } val wasmJsMain by getting { dependencies { // Ktor Client Engine implementation(libs.ktor.client.js) } } commonTest.dependencies { implementation(libs.kotlin.test) } } } android { namespace = \"ru.alekseev.myapplication.shared\" compileSdk = libs.versions.android.compileSdk.get().toInt() defaultConfig { minSdk = libs.versions.android.minSdk.get().toInt() } compileOptions { val jvmTargetVersion = libs.versions.jvmTarget.get().toInt() sourceCompatibility = JavaVersion.toVersion(jvmTargetVersion) targetCompatibility = JavaVersion.toVersion(jvmTargetVersion) } }",
            "startTokenIndex": 0,
            "endTokenIndex": 181,
            "fileType": "kts"
        },
        {
            "chunkId": "48fd5c70-7273-45d8-8904-ea62e355141c",
            "filePath": "DAY_15_QUICK_START.md",
            "content": "Error: Cannot read binary file: DAY_15_QUICK_START.md",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "md"
        },
        {
            "chunkId": "7dfb27ef-fe40-477c-81f6-2a90c83839f6",
            "filePath": "DAY_15_SETUP.md",
            "content": "# Day 15: MCP DevOps Integration This document describes how to set up and use the DevOps MCP server that allows Claude (via your Ktor server) to control Docker, build Android apps, and deploy to an emulator. ## Overview The DevOps MCP server is a **separate module** (`mcp-server-devops`) that runs on your Mac host machine. This is different from the main MCP server (`mcp-server`) which handles Calendar and Reminders via stdio. ## Architecture ```   Mac Host          DevOps MCP Server  Android SDK/Emulator     (Port 8082)   Docker Engine       Gradle Build         HTTP          Docker Container: myapplication-server               Ktor Server (Port 8080)       - MCPManager with MCPHttpClient       - Connects to host.docker.internal:8082               ``` ## Prerequisites 1. **Android SDK**: Installed on Mac with `ANDROID_HOME` set 2. **Android Emulator**: An AVD created and accessible via `adb` 3. **Docker**: Running on Mac with Docker socket accessible 4. **MCP Server JAR**: Built with `./gradlew :mcp-server:jar` ## Setup Instructions ### Step 1: Build the DevOps MCP Server ```bash ./gradlew :mcp-server-devops:jar ``` This creates: `mcp-server-devops/build/libs/mcp-server-devops-1.0.0.jar` ### Step 2: Start the DevOps MCP Server on Mac You have two options: #### Option A: Foreground (recommended for testing) ```bash ./start-devops-mcp.sh ``` Or manually: ```bash java -jar mcp-server-devops/build/libs/mcp-server-devops-1.0.0.jar 8082 ``` #### Option B: Background (recommended for daily use) ```bash ./start-devops-mcp-background.sh ``` This starts the server as a daemon. To stop it later: ```bash ./stop-devops-mcp.sh ``` You should see: ``` DevOps MCP Server running on http://localhost:8082/mcp Available tools: docker_ps, build_android_app, deploy_to_emulator Health check: http://localhost:8082/health ``` ### Step 3: Start an Android Emulator In another terminal: ```bash # List available AVDs emulator -list-avds # Start an emulator (replace with your AVD name) emulator -avd Pixel_5_API_33 & # Verify it's running adb devices ``` ### Step 4: Start Your Ktor Server (in Docker) ```bash docker-compose up server ``` Check the logs for: ``` Registering DevOps MCP HTTP client at http://host.docker.internal:8082 Registered DevOps MCP HTTP client (will connect when server starts) ``` ### Step 5: Connect to Your Application Open your web application at http://localhost:8080 and start chatting with Claude. ## Available MCP Tools ### 1. `docker_ps` Lists all running Docker containers. **Example prompt to Claude:** ``` \"Show me which Docker containers are currently running\" ``` **Tool Input:** None **Tool Output:** ``` Docker Containers: CONTAINER ID NAMES STATUS PORTS abc123def456 myapplication-server Up 2 hours 0.0.0.0:8081->8080/tcp ``` ### 2. `build_android_app` Builds the Android application using Gradle assembleDebug. **Example prompt to Claude:** ``` \"Build the Android app for me\" \"Build the app with a clean build\" ``` **Tool Input:** - `clean` (optional, boolean): Whether to run clean before build (default: false) **Tool Output:** ``` Build successful! APK location: /Users/artemalekseev/AndroidStudioProjects/MyApplication4/composeApp/build/outputs/apk/debug/composeApp-debug.apk Build output: BUILD SUCCESSFUL in 1m 23s 42 actionable tasks: 42 executed ``` ### 3. `deploy_to_emulator` Installs the APK on a running emulator and launches the app. **Example prompt to Claude:** ``` \"Deploy the app to the emulator\" \"Install the APK at /path/to/app.apk on the emulator\" ``` **Tool Input:** - `apk_path` (required, string): Path to the APK file to install - `package_name` (optional, string): Package name to launch (default: ru.alekseev.myapplication) **Tool Output:** ``` Successfully deployed to emulator! Install output: Performing Streamed Install Success Launch output: Starting: Intent { cmp=ru.alekseev.myapplication/.MainActivity } ``` ## Complete Workflow Example Here's a complete conversation you can have with Claude: ``` User: \"I want to verify my app is working on a real device. Can you help me?\" Claude: [Uses docker_ps to check containers are running] User: \"Build the app and deploy it to my emulator\" Claude: [Uses build_android_app to build the APK] Claude: [Uses deploy_to_emulator with the APK path from the build] User: \"Great! The app is running on my emulator\" ``` ## Troubleshooting ### DevOps MCP Server won't start - Check port 8082 is not already in use: `lsof -i :8082` - Verify JAR exists: `ls -la mcp-server/build/libs/mcp-server-1.0.0.jar` ### Ktor server can't connect to DevOps MCP - Verify DevOps MCP server is running on Mac - Check Docker can reach host: `docker exec myapplication-server curl http://host.docker.internal:8082/health` - Check logs in Ktor server for connection errors ### Build fails - Verify you're in the correct directory (project root) - Check `./gradlew` is executable: `chmod +x gradlew` - Try building manually: `./gradlew :composeApp:assembleDebug` ### Emulator not found - Check emulator is running: `adb devices` - Verify ADB is in PATH: `which adb` - Start ADB server: `adb start-server` ### Deploy fails with \"MainActivity not found\" - Check package name in build.gradle.kts: `namespace = \"ru.alekseev.myapplication\"` - Verify MainActivity exists in composeApp/src/androidMain - Try launching manually: `adb shell am start -n ru.alekseev.myapplication/.MainActivity` ## Testing the Integration ### Manual Test 1. Start DevOps MCP server 2. Start emulator 3. Start Ktor server in Docker 4. In your web UI, ask Claude: \"List running Docker containers\" 5. Ask: \"Build the Android app\" 6. Ask: \"Deploy it to the emulator\" ### Verification - Docker containers listed correctly - APK builds successfully - APK installs on emulator - App launches on emulator ## Technical Details ### HTTP Communication The Ktor server (in Docker) connects to the DevOps MCP server (on Mac host) via HTTP: - Endpoint: `http://host.docker.internal:8082/mcp` - Protocol: JSON-RPC 2.0 over HTTP POST - Health check: `http://host.docker.internal:8082/health` ### Process Execution The DevOps MCP server executes commands on the Mac host: - Docker: `docker ps` - Gradle: `./gradlew :composeApp:assembleDebug` - ADB: `adb install -r <apk>` and `adb shell am start` ### Security Considerations - DevOps MCP server runs with your user permissions - Can execute arbitrary commands (docker, gradle, adb) - Only expose on localhost (127.0.0.1:8082) - Use authentication if exposing to network ## Next Steps 1. **Add more tools**: Screenshots, logcat, app restart 2. **CI/CD Integration**: Automate testing after deployment 3. **Multiple devices**: Support deploying to multiple emulators 4. **Real device support**: Deploy to physical devices via USB 5.",
            "startTokenIndex": 0,
            "endTokenIndex": 1024,
            "fileType": "md"
        },
        {
            "chunkId": "40cc28d0-3965-476c-9e1e-9fcd673fb20f",
            "filePath": "DAY_15_SETUP.md",
            "content": "Execution The DevOps MCP server executes commands on the Mac host: - Docker: `docker ps` - Gradle: `./gradlew :composeApp:assembleDebug` - ADB: `adb install -r <apk>` and `adb shell am start` ### Security Considerations - DevOps MCP server runs with your user permissions - Can execute arbitrary commands (docker, gradle, adb) - Only expose on localhost (127.0.0.1:8082) - Use authentication if exposing to network ## Next Steps 1. **Add more tools**: Screenshots, logcat, app restart 2. **CI/CD Integration**: Automate testing after deployment 3. **Multiple devices**: Support deploying to multiple emulators 4. **Real device support**: Deploy to physical devices via USB 5. **Test execution**: Run instrumented tests after deployment ## Module Structure This project now has **two separate MCP server modules**: ### 1. `mcp-server` (Calendar & Reminders) - **Purpose**: Google Calendar and Reminder tools - **Connection**: stdio (launched by Ktor server via ProcessBuilder) - **Location**: Runs inside Docker container - **Tools**: calendar_*, reminder_* ### 2. `mcp-server-devops` (DevOps Tools) - **Purpose**: Docker, Gradle builds, Android deployment - **Connection**: HTTP (connects to host via `host.docker.internal:8082`) - **Location**: Runs on Mac host machine - **Tools**: docker_ps, build_android_app, deploy_to_emulator ## File References ### DevOps Module (`mcp-server-devops/`) - Main entry: `src/main/kotlin/ru/alekseev/mcp/devops/Main.kt` - DevOps Tools: `src/main/kotlin/ru/alekseev/mcp/devops/DevOpsToolProvider.kt` - HTTP Server: `src/main/kotlin/ru/alekseev/mcp/devops/MCPHttpServer.kt` - MCP Server: `src/main/kotlin/ru/alekseev/mcp/devops/MCPServer.kt` ### Server Integration - HTTP Client: `server/src/main/kotlin/ru/alekseev/myapplication/service/MCPHttpClient.kt` - Registration: `server/src/main/kotlin/ru/alekseev/myapplication/di/AppModule.kt:147-160` ### Startup Scripts - Foreground: `start-devops-mcp.sh` - Background: `start-devops-mcp-background.sh` - Stop daemon: `stop-devops-mcp.sh`",
            "startTokenIndex": 924,
            "endTokenIndex": 1153,
            "fileType": "md"
        },
        {
            "chunkId": "be5ee281-d087-4e4c-914e-dda4d2207fc1",
            "filePath": "DAY_16_DOCUMENT_INDEXING.md",
            "content": "``` ### Out of Memory - Reduce batch size in `IndexingPipeline` - Process files incrementally - Increase JVM heap: `./gradlew -Xmx2g :server-doc-indexer:run` ### Slow Embedding Generation - Use GPU-accelerated Ollama - Reduce chunk size (e.g., 512 tokens) - Skip large documentation files ## Future Enhancements 1. **Incremental Updates**: Track file modifications, re-index only changed files 2. **FAISS Native Bindings**: Use `faiss-java` for production-scale indexing 3. **Multi-Model Support**: Allow different embedding models 4. **Metadata Enrichment**: Add code language detection, AST parsing 5. **Distributed Indexing**: Process files in parallel across workers 6. **Semantic Deduplication**: Detect and merge similar chunks ## Summary  **Clean Architecture**: Domain/Data separation  **DRY Principles**: Reusable components  **MCP Integration**: Filesystem access via tools  **Configurable**: Chunk size, overlap, model  **Persistent**: Saves index + metadata to disk  **Production-Ready**: Error handling, logging, security **Complete!** ",
            "startTokenIndex": 924,
            "endTokenIndex": 1064,
            "fileType": "md"
        },
        {
            "chunkId": "d8adca47-159c-4386-9ae5-120da5545fe2",
            "filePath": "DAY_16_SERVER_RAG_INTEGRATION.md",
            "content": "indexer: ```bash ./gradlew :server-doc-indexer:run ``` ### Ollama Not Running ``` [DocumentRAGService] Search failed: Connection refused ``` **Solution:** Start Ollama: ```bash ollama serve ollama pull nomic-embed-text ``` ### MCP Server Not Running ``` Failed to connect to MCP server ``` **Solution:** Start the MCP server: ```bash ./start-devops-mcp.sh ``` ### No Context Retrieved If RAG returns empty results: 1. Check if index is loaded: `documentRAGService.isReady()` 2. Verify index has data: `documentRAGService.getStats()` 3. Test search directly: `documentRAGService.search(\"test query\")` ## Example Usage ### Question: \"How does MCP work in this project?\" **RAG Process:** 1. Query embedding generated 2. Search finds relevant chunks from: - `server/src/main/kotlin/ru/alekseev/myapplication/service/MCPManager.kt` - `server/src/main/kotlin/ru/alekseev/myapplication/service/MCPClient.kt` - `server/src/main/kotlin/ru/alekseev/myapplication/di/AppModule.kt` 3. Context added to prompt: ``` Here is relevant context from the project codebase: --- Document 1 (server/.../MCPManager.kt, similarity: 0.891) --- class MCPManager { private val clients = mutableMapOf<String, MCPClient>() fun registerClient(name: String, client: MCPClient) { clients[name] = client } suspend fun callTool(toolName: String, input: JsonObject?): String { // Find the client that supports this tool ... } } --- Document 2 (server/.../AppModule.kt, similarity: 0.856) --- val mcpManager = MCPManager() // Configure Google Calendar MCP Server val calendarClient = MCPClient( name = \"google-calendar\", command = listOf(\"java\", \"-jar\", mcpServerJar), ... ) mcpManager.registerClient(\"google-calendar\", calendarClient) ... ``` 4. Claude receives full context 5. Response: \"MCP (Model Context Protocol) is implemented using a manager-client architecture. The MCPManager class manages multiple MCP clients...\" **Result:** Accurate, code-based answer! ## Benefits  **Accurate Answers:** Based on actual codebase, not hallucinations  **No Manual Context:** Automatically finds relevant code  **Up-to-Date:** Re-index to stay current  **Transparent:** See which files were used (similarity scores)  **Scalable:** Works for projects of any size  **Fast:** Sub-second search for small projects ## Next Steps ### Enhancements 1. **API Endpoint for Stats** ```kotlin get(\"/api/rag/stats\") { call.respond(documentRAGService.getStats()) } ``` 2. **Manual Re-index Trigger** ```kotlin post(\"/api/rag/reindex\") { launch { documentRAGService.reindex() } } ``` 3. **Query History** - Track which chunks are most useful - Improve ranking over time 4. **Hybrid Search** - Combine semantic search with keyword search - Better for exact matches (function names, etc.) 5. **Metadata Filtering** - Search only `.kt` files - Exclude test files - Filter by directory ## Summary The RAG integration is now **fully functional** and runs automatically inside the server: -  Index loaded on server startup -  Automatic semantic search for all queries -  Context added to Claude prompts -  No external scripts required -  Production-ready **You can now ask questions about your codebase and get accurate answers powered by your actual code!**",
            "startTokenIndex": 924,
            "endTokenIndex": 1341,
            "fileType": "md"
        },
        {
            "chunkId": "8e62e730-8b65-4b99-a5b7-fd66640a593f",
            "filePath": "DOCKER.md",
            "content": "Error: Cannot read binary file: DOCKER.md",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "md"
        },
        {
            "chunkId": "6136e38a-9c55-4d46-9785-31503bc3d1a0",
            "filePath": "GITHUB_MCP_SETUP.md",
            "content": "# GitHub MCP Server Setup Guide ## Overview This project now integrates GitHub's official MCP server, providing 100+ tools for repository management, issues, PRs, CI/CD monitoring, and more. ## Prerequisites - Docker installed and running - GitHub account - GitHub Personal Access Token (PAT) ## Setup Steps ### 1. Create GitHub Personal Access Token 1. Go to GitHub Settings: https://github.com/settings/tokens 2. Click \"Generate new token\"  \"Generate new token (classic)\" 3. Name: `MCP Server` (or any name you prefer) 4. Select scopes (minimum required): - `repo` (Full control of private repositories) - `read:org` (Read org and team membership) - `read:user` (Read user profile data) - `read:project` (Read project data) **Note**: For more features, you may want to add: - `workflow` (Update GitHub Actions workflows) - `admin:repo_hook` (Full control of repository hooks) - `notifications` (Access notifications) 5. Click \"Generate token\" 6. **Copy the token immediately** (you won't be able to see it again) ### 2. Set Environment Variable **Option A: Temporary (current session only)** ```bash export GITHUB_PERSONAL_ACCESS_TOKEN=\"ghp_your_token_here\" ``` **Option B: Persistent (recommended)** Add to your shell profile (`~/.zshrc` for macOS default, or `~/.bashrc`): ```bash echo 'export GITHUB_PERSONAL_ACCESS_TOKEN=\"ghp_your_token_here\"' >> ~/.zshrc source ~/.zshrc ``` **Option C: IntelliJ IDEA Run Configuration** 1. Edit Run Configuration for your server 2. Add environment variable: `GITHUB_PERSONAL_ACCESS_TOKEN=ghp_your_token_here` ### 3. Verify Docker Image The image should already be pulled: ```bash docker images | grep github-mcp-server ``` Expected output: ``` ghcr.io/github/github-mcp-server latest ... ... ``` ### 4. Test GitHub MCP Server Manually (Optional) Test the Docker container directly: ```bash echo '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2024-11-05\",\"capabilities\":{},\"clientInfo\":{\"name\":\"test\",\"version\":\"1.0\"}}}' | docker run -i --rm -e GITHUB_PERSONAL_ACCESS_TOKEN=$GITHUB_PERSONAL_ACCESS_TOKEN ghcr.io/github/github-mcp-server ``` You should see a JSON response with capabilities. ### 5. Start Your Server The GitHub MCP client is already configured in `AppModule.kt` and will auto-register when: 1. Docker is running 2. `GITHUB_PERSONAL_ACCESS_TOKEN` environment variable is set Start your server: ```bash ./gradlew :server:run ``` Look for these log messages: ``` Found GitHub token, registering GitHub MCP client Registered GitHub MCP client ``` ## Integration Details ### Architecture ``` User Chat Message  ClaudeApiService  MCPManager (routes tool calls)  GitHub MCPClient  Docker Container (GitHub MCP Server)  GitHub REST API ``` ### Configuration Location - **Main Config**: `server/src/main/kotlin/ru/alekseev/myapplication/di/AppModule.kt` (lines 123-145) - **Docker Command**: Uses `-i` (interactive) and `--rm` (auto-remove) - **Environment**: Token passed via `-e` flag to Docker ### Available Tools Once connected, Claude will have access to 100+ GitHub tools including: **Repository Tools**: - `get_file_contents` - Read file contents - `search_code` - Search code in repositories - `list_commits` - List commit history - `get_repository` - Get repository metadata - `list_repositories` - List user/org repositories **Issue & PR Tools**: - `create_issue` - Create new issue - `list_issues` - List issues with filters - `create_pull_request` - Create PR - `list_pull_requests` - List PRs - `merge_pull_request` - Merge PR **CI/CD Tools**: - `list_workflows` - List GitHub Actions workflows - `list_workflow_runs` - List workflow run history - `get_workflow_run` - Get run details **And many more** for branches, releases, gists, projects, etc. ## Usage Example Once set up, you can ask Claude: ``` \"Go to https://github.com/anthropics/anthropic-sdk-python, analyze the repository and save a summary to my reminders\" ``` Claude will: 1. Detect the GitHub URL 2. Autonomously call GitHub tools (get_repository, get_file_contents, etc.) 3. Summarize the findings using LLM 4. Save to Reminder MCP tool ## Troubleshooting ### Error: \"GITHUB_PERSONAL_ACCESS_TOKEN not found\" - Verify the token is set: `echo $GITHUB_PERSONAL_ACCESS_TOKEN` - Make sure you restarted your terminal after adding to shell profile - Check IntelliJ run configuration if running from IDE ### Error: \"Cannot connect to Docker daemon\" - Start Docker Desktop - Verify: `docker ps` ### Error: \"rate limit exceeded\" - Check your token scopes include `repo` - Wait for rate limit reset (check headers in GitHub API responses) - Consider upgrading GitHub plan for higher limits ### Docker image not found ```bash docker pull ghcr.io/github/github-mcp-server:latest ``` ### MCP connection timeout - Check Docker logs: `docker logs $(docker ps -q --filter ancestor=ghcr.io/github/github-mcp-server)` - Verify token has correct permissions - Check network connectivity ## Security Notes - **Never commit tokens**: Add `.env` files to `.gitignore` - **Use fine-grained tokens** when possible for better security - **Rotate tokens regularly**: Generate new ones every 90 days - **Minimal scopes**: Only grant permissions you need - **Revoke unused tokens**: Clean up old tokens at https://github.com/settings/tokens ## References - [GitHub MCP Server Official Repo](https://github.com/github/github-mcp-server) - [GitHub PAT Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens) - [Model Context Protocol Spec](https://modelcontextprotocol.io/)",
            "startTokenIndex": 0,
            "endTokenIndex": 724,
            "fileType": "md"
        },
        {
            "chunkId": "b75d9508-4999-4855-b188-7687ac5d0e51",
            "filePath": "GOOGLE_CALENDAR_SETUP.md",
            "content": "Error: Cannot read binary file: GOOGLE_CALENDAR_SETUP.md",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "md"
        },
        {
            "chunkId": "9cda6b9f-6ab3-4499-8b9d-9817594fc5ba",
            "filePath": "MCP_INTEGRATION_SUMMARY.md",
            "content": "Error: Cannot read binary file: MCP_INTEGRATION_SUMMARY.md",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "md"
        },
        {
            "chunkId": "9bc65a60-58fd-4e4d-bfe2-7c1541ca25e0",
            "filePath": "MCP_SETUP_GUIDE.md",
            "content": "Error: Cannot read binary file: MCP_SETUP_GUIDE.md",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "md"
        },
        {
            "chunkId": "6eb6635c-6a6e-4285-9a3c-c3c7c393abdd",
            "filePath": "QUICK_START.md",
            "content": "Error: Cannot read binary file: QUICK_START.md",
            "startTokenIndex": 0,
            "endTokenIndex": 6,
            "fileType": "md"
        },
        {
            "chunkId": "ebf9fc2a-7fdf-4775-946c-ddec43063901",
            "filePath": "QUICK_START_RAG.md",
            "content": "# Quick Start: RAG-Powered Chat Ask questions about your codebase and get accurate answers from Claude with automatic context retrieval. ## Prerequisites ```bash # 1. Install Ollama (if not installed) # Visit: https://ollama.ai # 2. Pull the embedding model ollama pull nomic-embed-text # 3. Start Ollama (if not running) # Ollama runs automatically on macOS after installation # Check: curl http://localhost:11434/api/tags ``` ## One-Time Setup: Create Document Index ```bash # 1. Start MCP DevOps server (provides filesystem access for indexing) ./start-devops-mcp.sh # 2. Run the indexer (in a new terminal) ./gradlew :server-doc-indexer:run ``` **Expected Output:** ``` === Starting Document Indexing Pipeline === Step 1: Crawling project files... Found 42 files to process Step 2: Reading and chunking files... ./server/build.gradle.kts: 12 chunks ./server/src/main/kotlin/ru/alekseev/myapplication/Application.kt: 8 chunks ... Total chunks created: 156 Files processed: 42 Step 3: Generating embeddings using Ollama... Progress: 10 / 156 Progress: 20 / 156 ... Step 4: Building vector index... Index size: 156 vectors Step 5: Saving index to disk... Index saved to: /Users/.../faiss_index/project.index Metadata saved to: /Users/.../faiss_index/metadata.json === Indexing Complete === ``` **Note:** This creates `./faiss_index/` with your project's knowledge base. ## Running the Server ```bash # Start the server (RAG loads automatically) ./gradlew :server:run ``` **Expected Output:** ``` [DocumentRAGService] Loading index from ./faiss_index/project.index [DocumentRAGService] Index loaded successfully with 156 vectors [DocumentRAGService] Metadata loaded: 156 chunks from 42 files Document RAG Service initialized successfully - Total vectors: 156 - Total files: 42 - Indexed at: 2025-12-22T18:00:00Z ``` ## Usage: Ask Questions Connect to the server via WebSocket at `ws://localhost:8080/chat` and ask questions about your project! ### Example Questions **About the code:** - \"Which Claude LLM model is used in this project?\" - \"How does the MCP integration work?\" - \"Show me the database schema\" - \"What is the chat message flow?\" - \"How are websockets configured?\" **About configuration:** - \"What dependencies does the server use?\" - \"How is Koin DI configured?\" - \"What ports does the server use?\" **About architecture:** - \"Explain the project structure\" - \"How is Clean Architecture implemented?\" - \"What are the main modules?\" ### How It Works 1. **You ask:** \"Which Claude model is used?\" 2. **RAG searches:** Finds relevant code chunks from `ClaudeApiService.kt` 3. **Context added:** Code snippets added to Claude prompt 4. **Claude answers:** With accurate information from your codebase 5. **You get:** Correct answer based on actual code! ## Re-indexing Update the index after making code changes: ```bash # Make sure MCP server is running ./start-devops-mcp.sh # Re-run the indexer ./gradlew :server-doc-indexer:run ``` **Tip:** Re-index after: - Adding new files - Major code changes - Updating documentation ## Troubleshooting ### \"Index not found\" ```bash # Run the indexer first ./gradlew :server-doc-indexer:run ``` ### \"Ollama connection failed\" ```bash # Check if Ollama is running curl http://localhost:11434/api/tags # If not, start it (it usually auto-starts on macOS) # Or pull the model again ollama pull nomic-embed-text ``` ### \"MCP server not running\" ```bash # Start the MCP server ./start-devops-mcp.sh # Verify it's running curl http://localhost:8082/health ``` ## Architecture ```   User Query   \"Which Claude model is used?\"    v   ProcessUserMessageUseCase   (orchestrates message processing)    v   DocumentRAGService   - Generate query embedding (Ollama)   - Search vector index (cosine similarity)   - Retrieve top 3 matching chunks    v   Context String   \"Here is relevant context:   --- Document 1 (ClaudeApiService.kt) ---   class ClaudeApiService {   val apiKey: String   ...   }\"    v   Claude API Call   Prompt: [context + conversation + query]    v   Claude Response   \"This project uses Claude Sonnet 3.5   via the Anthropic API. The model is   configured in ClaudeApiService...\"   ``` ## Files Created After indexing: ``` ./faiss_index/  project.index # Vector embeddings (JSON format)  # Contains 768-dim vectors for each chunk   metadata.json # Chunk content and mappings # Maps chunk IDs to file paths and content ``` ## Performance **Small project (42 files, 156 chunks):** - Indexing time: ~3-5 minutes - Search time: < 100ms - Index size: ~2 MB **Large project (1000+ files, 5000+ chunks):** - Indexing time: ~20-30 minutes - Search time: < 500ms - Index size: ~50 MB ## Summary  **One-time setup:** Create index with `./gradlew :server-doc-indexer:run`  **Auto-loading:** Server loads index on startup  **Automatic RAG:** Context retrieved for every query  **Accurate answers:** Based on actual codebase  **No manual work:** Everything happens automatically **You're ready to chat with your codebase!** ",
            "startTokenIndex": 0,
            "endTokenIndex": 768,
            "fileType": "md"
        },
        {
            "chunkId": "b33e3901-b473-4d50-9879-c5bab4134fe9",
            "filePath": "README.md",
            "content": "This is a Kotlin Multiplatform project targeting Android, iOS, Web, Desktop (JVM), Server. * [/composeApp](./composeApp/src) is for code that will be shared across your Compose Multiplatform applications. It contains several subfolders: - [commonMain](./composeApp/src/commonMain/kotlin) is for code thats common for all targets. - Other folders are for Kotlin code that will be compiled for only the platform indicated in the folder name. For example, if you want to use Apples CoreCrypto for the iOS part of your Kotlin app, the [iosMain](./composeApp/src/iosMain/kotlin) folder would be the right place for such calls. Similarly, if you want to edit the Desktop (JVM) specific part, the [jvmMain](./composeApp/src/jvmMain/kotlin) folder is the appropriate location. * [/iosApp](./iosApp/iosApp) contains iOS applications. Even if youre sharing your UI with Compose Multiplatform, you need this entry point for your iOS app. This is also where you should add SwiftUI code for your project. * [/server](./server/src/main/kotlin) is for the Ktor server application. * [/shared](./shared/src) is for the code that will be shared between all targets in the project. The most important subfolder is [commonMain](./shared/src/commonMain/kotlin). If preferred, you can add code to the platform-specific folders here too. ### Build and Run Android Application To build and run the development version of the Android app, use the run configuration from the run widget in your IDEs toolbar or build it directly from the terminal: - on macOS/Linux ```shell ./gradlew :composeApp:assembleDebug ``` - on Windows ```shell .\\gradlew.bat :composeApp:assembleDebug ``` ### Build and Run Desktop (JVM) Application To build and run the development version of the desktop app, use the run configuration from the run widget in your IDEs toolbar or run it directly from the terminal: - on macOS/Linux ```shell ./gradlew :composeApp:run ``` - on Windows ```shell .\\gradlew.bat :composeApp:run ``` ### Build and Run Server To build and run the development version of the server, use the run configuration from the run widget in your IDEs toolbar or run it directly from the terminal: - on macOS/Linux ```shell ./gradlew :server:run ``` - on Windows ```shell .\\gradlew.bat :server:run ``` ### Build and Run Web Application #### Option 1: Local Development To build and run the development version of the web app, use the run configuration from the run widget in your IDE's toolbar or run it directly from the terminal: - for the Wasm target (faster, modern browsers): - on macOS/Linux ```shell ./gradlew :composeApp:wasmJsBrowserDevelopmentRun ``` - on Windows ```shell .\\gradlew.bat :composeApp:wasmJsBrowserDevelopmentRun ``` - for the JS target (slower, supports older browsers): - on macOS/Linux ```shell ./gradlew :composeApp:jsBrowserDevelopmentRun ``` - on Windows ```shell .\\gradlew.bat :composeApp:jsBrowserDevelopmentRun ``` #### Option 2: Docker (Recommended for Deployment) The easiest way to deploy the web application: ```shell # Quick start with Wasm (modern browsers) docker-compose up -d # Or with Makefile make run # For older browser support (JS) make run-js ``` Access the application at **http://localhost:8080** For detailed Docker instructions, see [DOCKER.md](./DOCKER.md). ### Build and Run iOS Application To build and run the development version of the iOS app, use the run configuration from the run widget in your IDEs toolbar or open the [/iosApp](./iosApp) directory in Xcode and run it from there. --- Learn more about [Kotlin Multiplatform](https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html), [Compose Multiplatform](https://github.com/JetBrains/compose-multiplatform/#compose-multiplatform), [Kotlin/Wasm](https://kotl.in/wasm/) We would appreciate your feedback on Compose/Web and Kotlin/Wasm in the public Slack channel [#compose-web](https://slack-chats.kotlinlang.org/c/compose-web). If you face any issues, please report them on [YouTrack](https://youtrack.jetbrains.com/newIssue?project=CMP).",
            "startTokenIndex": 0,
            "endTokenIndex": 546,
            "fileType": "md"
        },
        {
            "chunkId": "c1e35aed-584f-4729-b044-c2b5212eb895",
            "filePath": "build.gradle.kts",
            "content": "plugins { // this is necessary to avoid the plugins to be loaded multiple times // in each subproject's classloader alias(libs.plugins.androidApplication) apply false alias(libs.plugins.androidLibrary) apply false alias(libs.plugins.composeHotReload) apply false alias(libs.plugins.composeMultiplatform) apply false alias(libs.plugins.composeCompiler) apply false alias(libs.plugins.kotlinJvm) apply false alias(libs.plugins.kotlinMultiplatform) apply false alias(libs.plugins.ktor) apply false }",
            "startTokenIndex": 0,
            "endTokenIndex": 45,
            "fileType": "kts"
        },
        {
            "chunkId": "57290d3d-a0f3-439b-bf18-6ff806eaaa81",
            "filePath": "settings.gradle.kts",
            "content": "rootProject.name = \"MyApplication\" enableFeaturePreview(\"TYPESAFE_PROJECT_ACCESSORS\") pluginManagement { repositories { google { mavenContent { includeGroupAndSubgroups(\"androidx\") includeGroupAndSubgroups(\"com.android\") includeGroupAndSubgroups(\"com.google\") } } mavenCentral() gradlePluginPortal() } } dependencyResolutionManagement { repositories { google { mavenContent { includeGroupAndSubgroups(\"androidx\") includeGroupAndSubgroups(\"com.android\") includeGroupAndSubgroups(\"com.google\") } } mavenCentral() } } plugins { id(\"org.gradle.toolchains.foojay-resolver-convention\") version \"1.0.0\" } include(\":composeApp\") include(\":server\") include(\":mcp-server\") include(\":mcp-server-devops\") include(\":server-doc-indexer\") include(\":shared\") include(\":core-network\") include(\":core-common\") include(\":feature-main\") include(\":feature-welcome\")",
            "startTokenIndex": 0,
            "endTokenIndex": 53,
            "fileType": "kts"
        }
    ],
    "totalFiles": 165,
    "totalChunks": 162,
    "indexedAt": "2025-12-22T20:33:42.200091Z",
    "chunkSize": 1024,
    "overlapSize": 100,
    "embeddingModel": "nomic-embed-text"
}